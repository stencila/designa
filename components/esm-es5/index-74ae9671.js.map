{"version":3,"sources":["node_modules/@lezer/markdown/dist/index.js","node_modules/@codemirror/lang-markdown/dist/index.js"],"names":["CompositeBlock","type","value","from","hash","end","children","positions","this","hashProp","NodeProp","contextHash","create","parentHash","prototype","addChild","child","pos","prop","Tree","length","push","toTree","nodeSet","_this","last","Math","max","tree","types","balance","makeTree","NodeType","none","Type","LeafBlock","start","content","marks","parsers","Line","text","baseIndent","basePos","depth","markers","indent","next","forward","forwardInner","newPos","skipSpace","countIndent","charCodeAt","reset","pop","moveBase","to","moveBaseColumn","findColumn","addMarker","elt","i","goal","scrub","result","slice","skipForList","bl","cx","line","block","stack","size","OrderedList","isOrderedList","isBulletList","BulletList","isHorizontalRule","DefaultSkipMarkup","_a","Blockquote","QuoteMark","lineStart","space","ListItem","_cx","Document","ch","skipSpaceBack","isFencedCode","isBlockquote","breaking","count","isSetextUnderline","inList","isAtxHeading","EmptyLine","CommentEnd","ProcessingEnd","HTMLBlockStyle","isHTMLBlock","rest","e","test","getListIndent","indentAfter","indented","addCodeText","CodeText","DefaultBlockParsers","LinkReference","undefined","IndentedCode","base","pendingMarks","nextLine","_i","m","_b","pendingMarks_1","_c","_d","codeStart","filter","concat","addNode","buffer","writeElements","finish","CodeBlock","FencedCode","fenceEnd","len","infoFrom","infoTo","CodeMark","CodeInfo","first","textStart","textEnd","prevLineEnd","startContext","HorizontalRule","newBase","ListMark","ATXHeading","off","endOfSpace","after","buf","write","HeaderMark","parser","parseInline","node","ATXHeading1","HTMLBlock","trailing","nodeType","CommentBlock","ProcessingInstructionBlock","SetextHeading","LinkReferenceParser","leaf","stage","elts","advance","complete","addLeafElement","nextStage","parseLinkLabel","LinkMark","parseURL","skip","title","parseLinkTitle","titleEnd","lineEnd","SetextHeadingParser","underline","underlineMark","SetextHeading1","SetextHeading2","__spreadArray","DefaultLeafBlocks","_","DefaultEndLeaf","p","scanLineResult","BlockContext","input","fragments","ranges","atEnd","dontInject","Set","stoppedAt","rangeI","absoluteLineStart","absoluteLineEnd","FragmentCursor","readLine","Object","defineProperty","finishContext","mark","reuseFragment","blockParsers","_e","leafBlockParsers","parse","parser_1","lines","_f","_g","endLeafBlock","stop","_h","_j","parser_2","_k","_l","finishLeaf","stopAt","RangeError","moveTo","matches","taken","takeNodes","withoutGaps","gapFrom","gapTo","moveRangeI","parentType","scanLine","r","lineChunkAt","textOffset","nextFrom","handler","skipContextMarkup","Error","chunk","lineChunks","eol","indexOf","startComposite","getNodeType","addElement","injectMarks","top","addGaps","injectGaps","topNode","parser_3","inline","Paragraph","TreeElement","Buffer","offset","dont","has","rangeEnd","movePastNext","upto","inclusive","firstChild","nextSibling","propValues","MarkdownParser","_super","__extends","blockNames","inlineParsers","inlineNames","wrappers","call","nodeTypes","t","name","id","createParse","w","configure","spec","config","resolveConfig","nonEmpty","defineNodes","assign","nodeTypes_1","s","composite","some","group","define","props","NodeSet","extend","apply","remove","rm","parseBlock","spec_1","found","before","findName","splice","endLeaf","spec_2","wrap","InlineContext","outer","char","token","resolveMarkers","Parser","a","Array","isArray","conf","conc","b","wrapA","wrapB","inner","names","Escape","nodes","elts_1","writeTo","build","reused","topID","Element","startOff","EmphasisUnderscore","resolve","EmphasisAsterisk","LinkStart","ImageStart","InlineDelimiter","side","Escapable","Punctuation","RegExp","DefaultInline","escaped","append","Entity","exec","InlineCode","curSize","HTMLTag","url","URL","comment","Comment","procInst","ProcessingInstruction","Emphasis","pBefore","pAfter","sBefore","sAfter","leftFlanking","rightFlanking","canOpen","canClose","HardBreak","Link","Image","LinkEnd","parts","part","takeContent","link","finishLink","j","startPos","endPos","unshift","dest","label","LinkTitle","requireNonWS","min","LinkLabel","addDelimiter","open","close","emp","closeSize","k","element","keep","findOpeningDelimiter","startIndex","elements","eI","marks_1","NotLast","fragment","fragmentEnd","cursor","nextFragment","read","c","rPos","parent","childAfter","cur","fragEnd","openEnd","blockI","prevEnd","prevI","isAnonymous","add","is","keys","map","n","leftOverSpace","nextPos","parseCode","codeParser","htmlParser","parseMixed","info","infoNode","getChild","parser_4","overlay","StrikethroughDelim","Strikethrough","parseRow","startI","cellStart","cellEnd","esc","parseCell","hasPipe","str","delimiterLine","TableParser","rows","lineText","firstRow","firstCount","Table","TaskParser","TaskList","GFM","parseSubSuper","next_1","Superscript","Subscript","Emoji","match","data","defineLanguageFacet","commonmark","styleTags","Blockquote/...","tags","quote","contentSeparator","ATXHeading1/... SetextHeading1/...","heading1","ATXHeading2/... SetextHeading2/...","heading2","ATXHeading3/...","heading3","ATXHeading4/...","heading4","ATXHeading5/...","heading5","ATXHeading6/...","heading6","Comment CommentBlock","escape","character","Emphasis/...","emphasis","StrongEmphasis/...","strong","Link/... Image/...","OrderedList/... BulletList/...","list","BlockQuote/...","InlineCode CodeText","monospace","HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark","processingInstruction","CodeInfo LinkLabel","labelName","string","foldNodeProp","state","doc","lineAt","indentNodeProp","languageDataProp","mkLang","Language","find","commonmarkLanguage","extended","TableDelimiter SubscriptMark SuperscriptMark StrikethroughMark","TableHeader/...","heading","Strikethrough/...","strikethrough","TaskMarker","atom","Task","Subscript Superscript","special","TableCell","markdownLanguage","getCodeParser","languages","defaultLanguage","LanguageDescription","matchLanguageName","support","language","ParseContext","getSkippingParser","load","nodeStart","sliceString","Context","spaceBefore","spaceAfter","item","blank","marker","number","String","itemNumber","getContext","context","node_1","renumberList","changes","prev","insert","insertNewlineContinueMarkup","dispatch","syntaxTree","changeByRange","range","empty","isActiveAt","resolveInner","emptyLine","delTo","insert_1","changes_1","EditorSelection","insert_2","lineBreak","prevLine","quoted","index","changes_2","continued","charAt","update","scrollIntoView","userEvent","isMark","contextNodeForDelete","scan","childBefore","lastChild","deleteMarkupBackward","spaceEnd","markdownKeymap","key","run","htmlNoMatch","html","matchClosingTags","markdown","codeLanguages","defaultCodeLanguage","addKeymap","extensions","defaultCode","LanguageSupport","Prec","high","keymap","of"],"mappings":"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","sourcesContent":["import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\n\nclass CompositeBlock {\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        let tree = new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n        return tree;\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"URL\"] = 33] = \"URL\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n})(Type || (Type = {}));\n/// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\nclass LeafBlock {\n    /// @internal\n    constructor(\n    /// The start position of the block.\n    start, \n    /// The block's text content.\n    content) {\n        this.start = start;\n        this.content = content;\n        /// @internal\n        this.marks = [];\n        /// The block parsers active for this block.\n        this.parsers = [];\n    }\n}\n/// Data structure used during block-level per-line parsing.\nclass Line {\n    constructor() {\n        /// The line's full text.\n        this.text = \"\";\n        /// The base indent provided by the composite contexts (that have\n        /// been handled so far).\n        this.baseIndent = 0;\n        /// The string position corresponding to the base indent.\n        this.basePos = 0;\n        /// The number of contexts handled @internal\n        this.depth = 0;\n        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        this.markers = [];\n        /// The position of the next non-whitespace character beyond any\n        /// list, blockquote, or other composite block markers.\n        this.pos = 0;\n        /// The column of the next non-whitespace character.\n        this.indent = 0;\n        /// The character code of the character after `pos`.\n        this.next = -1;\n    }\n    /// @internal\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /// @internal\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /// Skip whitespace after the given position, return the position of\n    /// the next non-space character or the end of the line if there's\n    /// only space after `from`.\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /// @internal\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /// Move the line's base position forward to the given position.\n    /// This should only be called by composite [block\n    /// parsers](#BlockParser.parse) or [markup skipping\n    /// functions](#NodeSpec.composite).\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /// Move the line's base position forward to the given _column_.\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /// Store a composite-block-level marker. Should be called from\n    /// [markup skipping functions](#NodeSpec.composite) when they\n    /// consume any non-whitespace characters.\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /// Find the column position at `to`, optionally starting at a given\n    /// position and column.\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /// Find the position corresponding to the given column.\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /// @internal\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* Link */ || this.stage == 3 /* Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/// Block-level parsing functions get access to this context object.\nclass BlockContext {\n    /// @internal\n    constructor(\n    /// The parser configuration used.\n    parser, \n    /// @internal\n    input, fragments, \n    /// @internal\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /// @internal\n        this.dontInject = new Set;\n        this.stoppedAt = null;\n        /// The range index that absoluteLineStart points into @internal\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            while (line.depth < this.stack.length)\n                this.finishContext();\n            for (let mark of line.markers)\n                this.addNode(mark.type, mark.from, mark.to);\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        let withoutGaps = taken, end = this.absoluteLineStart + taken;\n        for (let i = 1; i < this.ranges.length; i++) {\n            let gapFrom = this.ranges[i - 1].to, gapTo = this.ranges[i].from;\n            if (gapFrom >= this.lineStart && gapTo < end)\n                withoutGaps -= gapTo - gapFrom;\n        }\n        this.lineStart += withoutGaps;\n        this.absoluteLineStart += taken;\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /// The number of parent blocks surrounding the current block.\n    get depth() {\n        return this.stack.length;\n    }\n    /// Get the type of the parent block at the given depth. When no\n    /// depth is passed, return the type of the innermost parent.\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /// Move to the next input line. This should only be called by\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\n    /// the line directly, or leaf block parser\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    /// consume the current line (and return true).\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to)\n            this.rangeI++;\n    }\n    /// @internal\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(r.end);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /// @internal\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /// The end position of the previous line.\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /// @internal\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /// Start a composite block. Should only be called from [block\n    /// parser functions](#BlockParser.parse) that return null.\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /// @internal\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /// Add a block element. Can be called by [block\n    /// parsers](#BlockParser.parse).\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\n    /// makes sure any extra composite block markup (such as blockquote\n    /// markers) inside the block are also added to the syntax tree.\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /// @internal\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.dontInject) : tree;\n    }\n    /// @internal\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /// @internal\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dont) {\n    if (dont.has(tree.tree))\n        return tree.tree;\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node;\n        if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dont);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/// A Markdown parser configuration.\nclass MarkdownParser extends Parser {\n    /// @internal\n    constructor(\n    /// The parser's syntax [node\n    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    nodeSet, \n    /// @internal\n    blockParsers, \n    /// @internal\n    leafBlockParsers, \n    /// @internal\n    blockNames, \n    /// @internal\n    endLeafBlock, \n    /// @internal\n    skipContextMarkup, \n    /// @internal\n    inlineParsers, \n    /// @internal\n    inlineNames, \n    /// @internal\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /// @internal\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Reconfigure the parser.\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice();\n            for (let s of config.defineNodes) {\n                let { name, block, composite } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n            }\n            nodeSet = new NodeSet(nodeTypes);\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /// @internal\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /// Parse the given piece of inline text at the given offset,\n    /// returning an array of [`Element`](#Element) objects representing\n    /// the inline content.\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]]\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/// Elements are used to compose syntax nodes during parsing.\nclass Element {\n    /// @internal\n    constructor(\n    /// The node's\n    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    type, \n    /// The start of the node, as an offset from the start of the document.\n    from, \n    /// The end of the node.\n    to, \n    /// The node's child nodes @internal\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /// @internal\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /// @internal\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url)\n            return cx.append(elt(Type.URL, start, start + 1 + url[0].length));\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Open */ : 0) | (canClose ? 2 /* Close */ : 0)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n            if (title)\n                pos = cx.skipSpace(title.to);\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\nclass InlineContext {\n    /// @internal\n    constructor(\n    /// The parser that is being used.\n    parser, \n    /// The text of this inline section.\n    text, \n    /// The starting offset of the section in the document.\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /// @internal\n        this.parts = [];\n    }\n    /// Get the character code at the given (document-relative)\n    /// position.\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /// The position of the end of this inline section.\n    get end() { return this.offset + this.text.length; }\n    /// Get a substring of this inline section. Again uses\n    /// document-relative positions.\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /// @internal\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\n    /// and `close` indicate whether this delimiter is opening, closing,\n    /// or both. Returns the end of the delimiter, for convenient\n    /// returning from [parse functions](#InlineParser.parse).\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Open */ : 0) | (close ? 2 /* Close */ : 0)));\n    }\n    /// Add an inline element. Returns the end of the element.\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /// @internal\n    resolveMarkers(from) {\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (!(part instanceof InlineDelimiter && (part.side & 1 /* Open */) && part.type == close.type) ||\n                    emp && ((close.side & 1 /* Open */) || (part.side & 2 /* Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))\n                    continue;\n                open = part;\n                break;\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /// Find an opening delimiter of the given type. Returns `null` if\n    /// no delimiter is found, or an index that can be passed to\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /// Remove all inline elements and delimiters starting from the\n    /// given index (which you should get from\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    /// resolve delimiters inside of them, and return them as an array\n    /// of elements.\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /// Skip space after the given (document) position, returning either\n    /// the position of the next non-space character or the end of the\n    /// section.\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            cx.dontInject.add(cur.tree);\n            cx.addNode(cur.tree, cur.from - off);\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\n/// The default CommonMark parser.\nconst parser = new MarkdownParser(new NodeSet(nodeTypes), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\nconst Strikethrough = {\n    defineNodes: [\"Strikethrough\", \"StrikethroughMark\"],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126)\n                    return -1;\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, true, true);\n            },\n            after: \"Emphasis\"\n        }]\n};\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        \"TableHeader\",\n        \"TableRow\",\n        \"TableCell\",\n        \"TableDelimiter\"\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true },\n        \"TaskMarker\"\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\n/// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList) and [`Strikethrough`](#Strikethrough).\nconst GFM = [Table, TaskList, Strikethrough];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\nconst Superscript = {\n    defineNodes: [\"Superscript\", \"SuperscriptMark\"],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\nconst Subscript = {\n    defineNodes: [\"Subscript\", \"SubscriptMark\"],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\nconst Emoji = {\n    defineNodes: [\"Emoji\"],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n","import { EditorSelection, Prec } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, Language, LanguageDescription, ParseContext, syntaxTree, LanguageSupport } from '@codemirror/language';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html } from '@codemirror/lang-html';\nimport { styleTags, tags } from '@codemirror/highlight';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ block: { open: \"<!--\", close: \"-->\" } });\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/styleTags({\n            \"Blockquote/...\": tags.quote,\n            HorizontalRule: tags.contentSeparator,\n            \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n            \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n            \"ATXHeading3/...\": tags.heading3,\n            \"ATXHeading4/...\": tags.heading4,\n            \"ATXHeading5/...\": tags.heading5,\n            \"ATXHeading6/...\": tags.heading6,\n            \"Comment CommentBlock\": tags.comment,\n            Escape: tags.escape,\n            Entity: tags.character,\n            \"Emphasis/...\": tags.emphasis,\n            \"StrongEmphasis/...\": tags.strong,\n            \"Link/... Image/...\": tags.link,\n            \"OrderedList/... BulletList/...\": tags.list,\n            \"BlockQuote/...\": tags.quote,\n            \"InlineCode CodeText\": tags.monospace,\n            URL: tags.url,\n            \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n            \"CodeInfo LinkLabel\": tags.labelName,\n            LinkTitle: tags.string,\n            Paragraph: tags.content\n        }),\n        /*@__PURE__*/foldNodeProp.add(type => {\n            if (!type.is(\"Block\") || type.is(\"Document\"))\n                return undefined;\n            return (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction mkLang(parser) {\n    return new Language(data, parser, parser.nodeSet.types.find(t => t.name == \"Document\"));\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji, {\n        props: [\n            /*@__PURE__*/styleTags({\n                \"TableDelimiter SubscriptMark SuperscriptMark StrikethroughMark\": tags.processingInstruction,\n                \"TableHeader/...\": tags.heading,\n                \"Strikethrough/...\": tags.strikethrough,\n                TaskMarker: tags.atom,\n                Task: tags.list,\n                Emoji: tags.character,\n                \"Subscript Superscript\": /*@__PURE__*/tags.special(tags.content),\n                TableCell: tags.content\n            })\n        ]\n    }]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        let found = info && LanguageDescription.matchLanguageName(languages, info, true);\n        if (!found)\n            return defaultLanguage ? defaultLanguage.parser : null;\n        if (found.support)\n            return found.support.language.parser;\n        return ParseContext.getSkippingParser(found.load());\n    };\n}\n\nfunction nodeStart(node, doc) {\n    return doc.sliceString(node.from, node.from + 50);\n}\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(trailing = true) {\n        let result = this.spaceBefore;\n        if (this.node.name == \"Blockquote\")\n            result += \">\";\n        else\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n        return result + (trailing ? this.spaceAfter : \"\");\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, line, doc) {\n    let nodes = [];\n    for (let cur = node; cur && cur.name != \"Document\"; cur = cur.parent) {\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\")\n            nodes.push(cur);\n    }\n    let context = [], pos = 0;\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match, start = pos;\n        if (node.name == \"Blockquote\" && (match = /^[ \\t]*>( ?)/.exec(line.slice(pos)))) {\n            pos += match[0].length;\n            context.push(new Context(node, start, pos, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^([ \\t]*)\\d+([.)])([ \\t]*)/.exec(nodeStart(node, doc)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            pos += len;\n            context.push(new Context(node.parent, start, pos, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^([ \\t]*)([-+*])([ \\t]+)/.exec(nodeStart(node, doc)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            pos += len;\n            context.push(new Context(node.parent, start, pos, match[1], after, match[2], node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), line.text, doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            // First list item or blank line before: delete a level of markup\n            if (inner.node.firstChild.to >= pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move this line down\n                let insert = \"\";\n                for (let i = 0, e = context.length - 2; i <= e; i++)\n                    insert += context[i].blank(i < e);\n                insert += state.lineBreak;\n                return { range: EditorSelection.cursor(pos + insert.length), changes: { from: line.from, insert } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let insert = state.lineBreak;\n        let continued = inner.item && inner.item.from < line.from;\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++)\n                insert += i == e && !continued ? context[i].marker(doc, 1) : context[i].blank();\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        changes.push({ from, to: pos, insert });\n        return { range: EditorSelection.cursor(from + insert.length), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), line.text, doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to)))\n                        return { range, changes: { from: start, to: line.from + inner.to, insert: inner.blank() } };\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlNoMatch.support], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages || [], defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    return new LanguageSupport(mkLang(parser.configure(extensions)), support);\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n"]}