{"version":3,"sources":["node_modules/mimic-fn/index.js","node_modules/p-defer/index.js","node_modules/map-age-cleaner/dist/index.js","node_modules/mem/dist/index.js","src/components/toast/toastController.ts"],"names":["copyProperty","to","from","property","ignoreNonConfigurable","toDescriptor","Object","getOwnPropertyDescriptor","fromDescriptor","canCopyProperty","defineProperty","undefined","configurable","writable","enumerable","value","changePrototype","fromPrototype","getPrototypeOf","setPrototypeOf","wrappedToString","withName","fromBody","concat","toStringDescriptor","Function","prototype","toStringName","toString","changeToString","name","trim","newToString","bind","__assign","mimicFn","_g","_h","_j","_i","_k","Reflect","ownKeys","length","mimicFn_1","pDefer","ret","promise","Promise","resolve","reject","__awaiter","this","thisArg","_arguments","P","generator","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","default","exports","p_defer_1","require$$0","mapAgeCleaner","map","_this","processingKey","processingTimer","processingDeferred","cleanup","setupTimer","item","delay","Date","now","delete","setTimeout","unref","map_1","entry","sent","reset","clearTimeout","originalSet","set","key","has","module","decoratorInstanceMap","WeakMap","cacheStore","mem","fn","cacheKey","cache","Map","maxAge","memoized","arguments_","arguments","cacheItem","get","data","Number","POSITIVE_INFINITY","decorator","options","target","propertyKey","descriptor","input","TypeError","clear","dist","ToastTypes","ToastPositions","init","toastContainer","document","querySelector","container","createElement","position","body","append","toastController","baseOptions","present","message","toastEl","type","_b","_a","neutral","_d","_c","topCenter","dismissable","_e","duration","_f","innerText","memoizedPresent","JSON","stringify"],"mappings":"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","sourcesContent":["'use strict';\n\nconst copyProperty = (to, from, property, ignoreNonConfigurable) => {\n\t// `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n\t// `Function#prototype` is non-writable and non-configurable so can never be modified.\n\tif (property === 'length' || property === 'prototype') {\n\t\treturn;\n\t}\n\n\t// `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\tif (property === 'arguments' || property === 'caller') {\n\t\treturn;\n\t}\n\n\tconst toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n\tconst fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n\tif (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n\t\treturn;\n\t}\n\n\tObject.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n//  - one its descriptors is changed\n//  - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n\treturn toDescriptor === undefined || toDescriptor.configurable || (\n\t\ttoDescriptor.writable === fromDescriptor.writable &&\n\t\ttoDescriptor.enumerable === fromDescriptor.enumerable &&\n\t\ttoDescriptor.configurable === fromDescriptor.configurable &&\n\t\t(toDescriptor.writable || toDescriptor.value === fromDescriptor.value)\n\t);\n};\n\nconst changePrototype = (to, from) => {\n\tconst fromPrototype = Object.getPrototypeOf(from);\n\tif (fromPrototype === Object.getPrototypeOf(to)) {\n\t\treturn;\n\t}\n\n\tObject.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n\tconst withName = name === '' ? '' : `with ${name.trim()}() `;\n\tconst newToString = wrappedToString.bind(null, withName, from.toString());\n\t// Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\tObject.defineProperty(newToString, 'name', toStringName);\n\tObject.defineProperty(to, 'toString', {...toStringDescriptor, value: newToString});\n};\n\nconst mimicFn = (to, from, {ignoreNonConfigurable = false} = {}) => {\n\tconst {name} = to;\n\n\tfor (const property of Reflect.ownKeys(from)) {\n\t\tcopyProperty(to, from, property, ignoreNonConfigurable);\n\t}\n\n\tchangePrototype(to, from);\n\tchangeToString(to, from, name);\n\n\treturn to;\n};\n\nmodule.exports = mimicFn;\n","'use strict';\nmodule.exports = () => {\n\tconst ret = {};\n\n\tret.promise = new Promise((resolve, reject) => {\n\t\tret.resolve = resolve;\n\t\tret.reject = reject;\n\t});\n\n\treturn ret;\n};\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst p_defer_1 = __importDefault(require(\"p-defer\"));\nfunction mapAgeCleaner(map, property = 'maxAge') {\n    let processingKey;\n    let processingTimer;\n    let processingDeferred;\n    const cleanup = () => __awaiter(this, void 0, void 0, function* () {\n        if (processingKey !== undefined) {\n            // If we are already processing an item, we can safely exit\n            return;\n        }\n        const setupTimer = (item) => __awaiter(this, void 0, void 0, function* () {\n            processingDeferred = p_defer_1.default();\n            const delay = item[1][property] - Date.now();\n            if (delay <= 0) {\n                // Remove the item immediately if the delay is equal to or below 0\n                map.delete(item[0]);\n                processingDeferred.resolve();\n                return;\n            }\n            // Keep track of the current processed key\n            processingKey = item[0];\n            processingTimer = setTimeout(() => {\n                // Remove the item when the timeout fires\n                map.delete(item[0]);\n                if (processingDeferred) {\n                    processingDeferred.resolve();\n                }\n            }, delay);\n            // tslint:disable-next-line:strict-type-predicates\n            if (typeof processingTimer.unref === 'function') {\n                // Don't hold up the process from exiting\n                processingTimer.unref();\n            }\n            return processingDeferred.promise;\n        });\n        try {\n            for (const entry of map) {\n                yield setupTimer(entry);\n            }\n        }\n        catch (_a) {\n            // Do nothing if an error occurs, this means the timer was cleaned up and we should stop processing\n        }\n        processingKey = undefined;\n    });\n    const reset = () => {\n        processingKey = undefined;\n        if (processingTimer !== undefined) {\n            clearTimeout(processingTimer);\n            processingTimer = undefined;\n        }\n        if (processingDeferred !== undefined) { // tslint:disable-line:early-exit\n            processingDeferred.reject(undefined);\n            processingDeferred = undefined;\n        }\n    };\n    const originalSet = map.set.bind(map);\n    map.set = (key, value) => {\n        if (map.has(key)) {\n            // If the key already exist, remove it so we can add it back at the end of the map.\n            map.delete(key);\n        }\n        // Call the original `map.set`\n        const result = originalSet(key, value);\n        // If we are already processing a key and the key added is the current processed key, stop processing it\n        if (processingKey && processingKey === key) {\n            reset();\n        }\n        // Always run the cleanup method in case it wasn't started yet\n        cleanup(); // tslint:disable-line:no-floating-promises\n        return result;\n    };\n    cleanup(); // tslint:disable-line:no-floating-promises\n    return map;\n}\nexports.default = mapAgeCleaner;\n// Add support for CJS\nmodule.exports = mapAgeCleaner;\nmodule.exports.default = mapAgeCleaner;\n","'use strict';\nconst mimicFn = require(\"mimic-fn\");\nconst mapAgeCleaner = require(\"map-age-cleaner\");\nconst decoratorInstanceMap = new WeakMap();\nconst cacheStore = new WeakMap();\n/**\n[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.\n\n@param fn - Function to be memoized.\n\n@example\n```\nimport mem = require('mem');\n\nlet i = 0;\nconst counter = () => ++i;\nconst memoized = mem(counter);\n\nmemoized('foo');\n//=> 1\n\n// Cached as it's the same arguments\nmemoized('foo');\n//=> 1\n\n// Not cached anymore as the arguments changed\nmemoized('bar');\n//=> 2\n\nmemoized('bar');\n//=> 2\n```\n*/\nconst mem = (fn, { cacheKey, cache = new Map(), maxAge } = {}) => {\n    if (typeof maxAge === 'number') {\n        // TODO: Drop after https://github.com/SamVerschueren/map-age-cleaner/issues/5\n        // @ts-expect-error\n        mapAgeCleaner(cache);\n    }\n    const memoized = function (...arguments_) {\n        const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\n        const cacheItem = cache.get(key);\n        if (cacheItem) {\n            return cacheItem.data;\n        }\n        const result = fn.apply(this, arguments_);\n        cache.set(key, {\n            data: result,\n            maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY\n        });\n        return result;\n    };\n    mimicFn(memoized, fn, {\n        ignoreNonConfigurable: true\n    });\n    cacheStore.set(memoized, cache);\n    return memoized;\n};\n/**\n@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.\n\n@example\n```\nimport mem = require('mem');\n\nclass Example {\n    index = 0\n\n    @mem.decorator()\n    counter() {\n        return ++this.index;\n    }\n}\n\nclass ExampleWithOptions {\n    index = 0\n\n    @mem.decorator({maxAge: 1000})\n    counter() {\n        return ++this.index;\n    }\n}\n```\n*/\nmem.decorator = (options = {}) => (target, propertyKey, descriptor) => {\n    const input = target[propertyKey];\n    if (typeof input !== 'function') {\n        throw new TypeError('The decorated value must be a function');\n    }\n    delete descriptor.value;\n    delete descriptor.writable;\n    descriptor.get = function () {\n        if (!decoratorInstanceMap.has(this)) {\n            const value = mem(input, options);\n            decoratorInstanceMap.set(this, value);\n            return value;\n        }\n        return decoratorInstanceMap.get(this);\n    };\n};\n/**\nClear all cached data of a memoized function.\n\n@param fn - Memoized function.\n*/\nmem.clear = (fn) => {\n    const cache = cacheStore.get(fn);\n    if (!cache) {\n        throw new TypeError('Can\\'t clear a function that was not memoized!');\n    }\n    if (typeof cache.clear !== 'function') {\n        throw new TypeError('The cache Map can\\'t be cleared!');\n    }\n    cache.clear();\n};\nmodule.exports = mem;\n","import mem from 'mem'\nimport { Components } from '../../components'\n\nexport enum ToastTypes {\n  neutral = 'neutral',\n  success = 'success',\n  warn = 'warn',\n  danger = 'danger',\n}\n\nexport type ToastType = keyof typeof ToastTypes\n\nexport enum ToastPositions {\n  topStart = 'topStart',\n  topCenter = 'topCenter',\n  topEnd = 'topEnd',\n  bottomStart = 'bottomStart',\n  bottomCenter = 'bottomCenter',\n  bottomEnd = 'bottomEnd',\n}\n\nexport type ToastPosition = keyof typeof ToastPositions\n\ntype ToastOptions = Partial<Components.StencilaToast>\n\nconst init = (options: ToastOptions): Element | HTMLElement => {\n  const toastContainer = document.querySelector('stencila-toast-container')\n\n  if (toastContainer) {\n    return toastContainer\n  }\n\n  const container = document.createElement('stencila-toast-container')\n\n  if (options.position !== undefined) {\n    container.position = options.position\n  }\n\n  document.body.append(container)\n  return container\n}\n\n// ==============================================================================\n\ninterface ToastController {\n  present: (message: string, options?: ToastOptions) => HTMLStencilaToastElement\n}\n\n// Base Toast controller function for managing the presentation of `stencila-toast` components\nexport const toastController = (\n  baseOptions: ToastOptions = {}\n): ToastController => {\n  const present = (\n    message: string,\n    options: ToastOptions | undefined = {}\n  ): HTMLStencilaToastElement => {\n    const toastEl = document.createElement('stencila-toast')\n\n    toastEl.type = options.type ?? baseOptions.type ?? ToastTypes.neutral\n    toastEl.position =\n      options.position ?? baseOptions.position ?? ToastPositions.topCenter\n    toastEl.dismissable = options.dismissable ?? baseOptions.dismissable\n    toastEl.duration = options.duration ?? baseOptions.duration\n\n    toastEl.innerText = message\n    init(baseOptions).append(toastEl)\n    return toastEl\n  }\n\n  /** Memoize the notification function based on the message string and options to avoid showing\n   * duplicate notifications in quick succession.\n   */\n  const memoizedPresent = mem(present, {\n    cacheKey: JSON.stringify,\n    maxAge: 150,\n  })\n\n  return {\n    present: memoizedPresent,\n  }\n}\n"]}