{"version":3,"sources":["node_modules/animate-presence/dist/collection/utils/path-to-regex.js","node_modules/animate-presence/dist/collection/utils/router.js","node_modules/animate-presence/dist/collection/components/animated-route-switch/animated-route-switch.js"],"names":["DEFAULT_DELIMITER","DEFAULT_DELIMITERS","PATH_REGEXP","RegExp","join","parse","str","options","tokens","key","index","path","defaultDelimiter","delimiter","delimiters","pathEscaped","res","exec","m","escaped","offset","slice","length","prev","next","name","capture","group","modifier","k","indexOf","push","partial","undefined","repeat","optional","pattern","prefix","escapeGroup","escapeString","substr","replace","flags","sensitive","regexpToRegexp","keys","groups","source","match","i","arrayToRegexp","parts","pathToRegexp","stringToRegexp","tokensToRegExp","strict","end","endsWith","concat","map","route","isEndDelimited","token","Array","isArray","cacheCount","patternCache","cacheLimit","compilePath","cacheKey","cache","cachePattern","JSON","stringify","re","compiledPattern","matchPath","pathname","_a","_b","exact","_c","_d","url","values","isExact","params","reduce","memo","getUniqueId","Math","random","toString","getMatch","isHTMLStencilRouteElement","elm","tagName","AnimatedRouteSwitch","class_1","hostRef","this","subscribers","prototype","componentWillLoad","location","regenerateSubscribers","console","warn","newLocation","log","newActiveIndex","call","el","children","filter","childElement","activeIndex","prevIndex","prevChild","exitChildren","sent","activeChild","scrollTopOffset","componentUpdated","routeViewUpdatedOptions","_this","queue","write","forEach","child","style","display","enterChildren","routeViewsUpdated","Object","assign","render","h"],"mappings":"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","sourcesContent":["/**\r\n * TS adaption of https://github.com/pillarjs/path-to-regexp/blob/master/index.js\r\n */\r\n/**\r\n * Default configs.\r\n */\r\nconst DEFAULT_DELIMITER = '/';\r\nconst DEFAULT_DELIMITERS = './';\r\n/**\r\n * The main path matching regexp utility.\r\n */\r\nconst PATH_REGEXP = new RegExp([\r\n    // Match escaped characters that would otherwise appear in future matches.\r\n    // This allows the user to escape special characters that won't transform.\r\n    '(\\\\\\\\.)',\r\n    // Match Express-style parameters and un-named parameters with a prefix\r\n    // and optional suffixes. Matches appear as:\r\n    //\r\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\r\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined]\r\n    '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?',\r\n].join('|'), 'g');\r\n/**\r\n * Parse a string for the raw tokens.\r\n */\r\nexport const parse = (str, options) => {\r\n    var tokens = [];\r\n    var key = 0;\r\n    var index = 0;\r\n    var path = '';\r\n    var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;\r\n    var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS;\r\n    var pathEscaped = false;\r\n    var res;\r\n    while ((res = PATH_REGEXP.exec(str)) !== null) {\r\n        var m = res[0];\r\n        var escaped = res[1];\r\n        var offset = res.index;\r\n        path += str.slice(index, offset);\r\n        index = offset + m.length;\r\n        // Ignore already escaped sequences.\r\n        if (escaped) {\r\n            path += escaped[1];\r\n            pathEscaped = true;\r\n            continue;\r\n        }\r\n        var prev = '';\r\n        var next = str[index];\r\n        var name = res[2];\r\n        var capture = res[3];\r\n        var group = res[4];\r\n        var modifier = res[5];\r\n        if (!pathEscaped && path.length) {\r\n            var k = path.length - 1;\r\n            if (delimiters.indexOf(path[k]) > -1) {\r\n                prev = path[k];\r\n                path = path.slice(0, k);\r\n            }\r\n        }\r\n        // Push the current path onto the tokens.\r\n        if (path) {\r\n            tokens.push(path);\r\n            path = '';\r\n            pathEscaped = false;\r\n        }\r\n        var partial = prev !== '' && next !== undefined && next !== prev;\r\n        var repeat = modifier === '+' || modifier === '*';\r\n        var optional = modifier === '?' || modifier === '*';\r\n        var delimiter = prev || defaultDelimiter;\r\n        var pattern = capture || group;\r\n        tokens.push({\r\n            name: name || key++,\r\n            prefix: prev,\r\n            delimiter: delimiter,\r\n            optional: optional,\r\n            repeat: repeat,\r\n            partial: partial,\r\n            pattern: pattern\r\n                ? escapeGroup(pattern)\r\n                : '[^' + escapeString(delimiter) + ']+?',\r\n        });\r\n    }\r\n    // Push any remaining characters.\r\n    if (path || index < str.length) {\r\n        tokens.push(path + str.substr(index));\r\n    }\r\n    return tokens;\r\n};\r\n/**\r\n * Compile a string to a template function for the path.\r\n */\r\nexport const compile = (str, options) => {\r\n    return tokensToFunction(parse(str, options));\r\n};\r\n/**\r\n * Expose a method for transforming tokens into the path function.\r\n */\r\nexport const tokensToFunction = (tokens) => {\r\n    // Compile all the tokens into regexps.\r\n    var matches = new Array(tokens.length);\r\n    // Compile all the patterns before compilation.\r\n    for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i];\r\n        if (typeof token === 'object') {\r\n            matches[i] = new RegExp('^(?:' + token.pattern + ')$');\r\n        }\r\n    }\r\n    return (data, options) => {\r\n        var path = '';\r\n        var encode = (options && options.encode) || encodeURIComponent;\r\n        for (var i = 0; i < tokens.length; i++) {\r\n            var token = tokens[i];\r\n            if (typeof token === 'string') {\r\n                path += token;\r\n                continue;\r\n            }\r\n            var value = data ? data[token.name] : undefined;\r\n            var segment;\r\n            if (Array.isArray(value)) {\r\n                if (!token.repeat) {\r\n                    throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array');\r\n                }\r\n                if (value.length === 0) {\r\n                    if (token.optional)\r\n                        continue;\r\n                    throw new TypeError('Expected \"' + token.name + '\" to not be empty');\r\n                }\r\n                for (var j = 0; j < value.length; j++) {\r\n                    segment = encode(value[j]);\r\n                    if (!matches[i].test(segment)) {\r\n                        throw new TypeError('Expected all \"' +\r\n                            token.name +\r\n                            '\" to match \"' +\r\n                            token.pattern +\r\n                            '\"');\r\n                    }\r\n                    path += (j === 0 ? token.prefix : token.delimiter) + segment;\r\n                }\r\n                continue;\r\n            }\r\n            if (typeof value === 'string' ||\r\n                typeof value === 'number' ||\r\n                typeof value === 'boolean') {\r\n                segment = encode(String(value));\r\n                if (!matches[i].test(segment)) {\r\n                    throw new TypeError('Expected \"' +\r\n                        token.name +\r\n                        '\" to match \"' +\r\n                        token.pattern +\r\n                        '\", but got \"' +\r\n                        segment +\r\n                        '\"');\r\n                }\r\n                path += token.prefix + segment;\r\n                continue;\r\n            }\r\n            if (token.optional) {\r\n                // Prepend partial segment prefixes.\r\n                if (token.partial)\r\n                    path += token.prefix;\r\n                continue;\r\n            }\r\n            throw new TypeError('Expected \"' +\r\n                token.name +\r\n                '\" to be ' +\r\n                (token.repeat ? 'an array' : 'a string'));\r\n        }\r\n        return path;\r\n    };\r\n};\r\n/**\r\n * Escape a regular expression string.\r\n */\r\nconst escapeString = (str) => {\r\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\r\n};\r\n/**\r\n * Escape the capturing group by escaping special characters and meaning.\r\n */\r\nconst escapeGroup = (group) => {\r\n    return group.replace(/([=!:$/()])/g, '\\\\$1');\r\n};\r\n/**\r\n * Get the flags for a regexp from the options.\r\n */\r\nconst flags = (options) => {\r\n    return options && options.sensitive ? '' : 'i';\r\n};\r\n/**\r\n * Pull out keys from a regexp.\r\n */\r\nconst regexpToRegexp = (path, keys) => {\r\n    if (!keys)\r\n        return path;\r\n    // Use a negative lookahead to match only capturing groups.\r\n    var groups = path.source.match(/\\((?!\\?)/g);\r\n    if (groups) {\r\n        for (var i = 0; i < groups.length; i++) {\r\n            keys.push({\r\n                name: i,\r\n                prefix: null,\r\n                delimiter: null,\r\n                optional: false,\r\n                repeat: false,\r\n                partial: false,\r\n                pattern: null,\r\n            });\r\n        }\r\n    }\r\n    return path;\r\n};\r\n/**\r\n * Transform an array into a regexp.\r\n */\r\nconst arrayToRegexp = (path, keys, options) => {\r\n    var parts = [];\r\n    for (var i = 0; i < path.length; i++) {\r\n        parts.push(pathToRegexp(path[i], keys, options).source);\r\n    }\r\n    return new RegExp('(?:' + parts.join('|') + ')', flags(options));\r\n};\r\n/**\r\n * Create a path regexp from string input.\r\n */\r\nconst stringToRegexp = (path, keys, options) => {\r\n    return tokensToRegExp(parse(path, options), keys, options);\r\n};\r\n/**\r\n * Expose a function for taking tokens and returning a RegExp.\r\n */\r\nexport const tokensToRegExp = (tokens, keys, options) => {\r\n    options = options || {};\r\n    var strict = options.strict;\r\n    var end = options.end !== false;\r\n    var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);\r\n    var delimiters = options.delimiters || DEFAULT_DELIMITERS;\r\n    var endsWith = []\r\n        .concat(options.endsWith || [])\r\n        .map(escapeString)\r\n        .concat('$')\r\n        .join('|');\r\n    var route = '';\r\n    var isEndDelimited = false;\r\n    // Iterate over the tokens and create our regexp string.\r\n    for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i];\r\n        if (typeof token === 'string') {\r\n            route += escapeString(token);\r\n            isEndDelimited =\r\n                i === tokens.length - 1 &&\r\n                    delimiters.indexOf(token[token.length - 1]) > -1;\r\n        }\r\n        else {\r\n            var prefix = escapeString(token.prefix || '');\r\n            var capture = token.repeat\r\n                ? '(?:' +\r\n                    token.pattern +\r\n                    ')(?:' +\r\n                    prefix +\r\n                    '(?:' +\r\n                    token.pattern +\r\n                    '))*'\r\n                : token.pattern;\r\n            if (keys)\r\n                keys.push(token);\r\n            if (token.optional) {\r\n                if (token.partial) {\r\n                    route += prefix + '(' + capture + ')?';\r\n                }\r\n                else {\r\n                    route += '(?:' + prefix + '(' + capture + '))?';\r\n                }\r\n            }\r\n            else {\r\n                route += prefix + '(' + capture + ')';\r\n            }\r\n        }\r\n    }\r\n    if (end) {\r\n        if (!strict)\r\n            route += '(?:' + delimiter + ')?';\r\n        route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';\r\n    }\r\n    else {\r\n        if (!strict)\r\n            route += '(?:' + delimiter + '(?=' + endsWith + '))?';\r\n        if (!isEndDelimited)\r\n            route += '(?=' + delimiter + '|' + endsWith + ')';\r\n    }\r\n    return new RegExp('^' + route, flags(options));\r\n};\r\n/**\r\n * Normalize the given path string, returning a regular expression.\r\n *\r\n * An empty array can be passed in for the keys, which will hold the\r\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\r\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\r\n */\r\nexport const pathToRegexp = (path, keys, options) => {\r\n    if (path instanceof RegExp) {\r\n        return regexpToRegexp(path, keys);\r\n    }\r\n    if (Array.isArray(path)) {\r\n        return arrayToRegexp(path, keys, options);\r\n    }\r\n    return stringToRegexp(path, keys, options);\r\n};\r\n","import { pathToRegexp } from './path-to-regex';\r\nlet cacheCount = 0;\r\nconst patternCache = {};\r\nconst cacheLimit = 10000;\r\n// Memoized function for creating the path match regex\r\nconst compilePath = (pattern, options) => {\r\n    const cacheKey = `${options.end}${options.strict}`;\r\n    const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\r\n    const cachePattern = JSON.stringify(pattern);\r\n    if (cache[cachePattern]) {\r\n        return cache[cachePattern];\r\n    }\r\n    const keys = [];\r\n    const re = pathToRegexp(pattern, keys, options);\r\n    const compiledPattern = { re, keys };\r\n    if (cacheCount < cacheLimit) {\r\n        cache[cachePattern] = compiledPattern;\r\n        cacheCount += 1;\r\n    }\r\n    return compiledPattern;\r\n};\r\n/**\r\n * Public API for matching a URL pathname to a path pattern.\r\n */\r\nexport const matchPath = (pathname, options = {}) => {\r\n    if (typeof options === 'string') {\r\n        options = { path: options };\r\n    }\r\n    const { path = '/', exact = false, strict = false } = options;\r\n    const { re, keys } = compilePath(path, { end: exact, strict });\r\n    const match = re.exec(pathname);\r\n    if (!match) {\r\n        return null;\r\n    }\r\n    const [url, ...values] = match;\r\n    const isExact = pathname === url;\r\n    if (exact && !isExact) {\r\n        return null;\r\n    }\r\n    return {\r\n        path,\r\n        url: path === '/' && url === '' ? '/' : url,\r\n        isExact,\r\n        params: keys.reduce((memo, key, index) => {\r\n            memo[key.name] = values[index];\r\n            return memo;\r\n        }, {}),\r\n    };\r\n};\r\n","import { h } from \"@stencil/core\";\r\nimport { matchPath } from '../../utils/router';\r\nimport { enterChildren, exitChildren } from '../../utils';\r\nconst getUniqueId = () => {\r\n    return ((Math.random() * 10e16).toString().match(/.{4}/g) || []).join('-');\r\n};\r\nconst getMatch = (pathname, url, exact) => {\r\n    return matchPath(pathname, {\r\n        path: url,\r\n        exact: exact,\r\n        strict: true,\r\n    });\r\n};\r\nconst isHTMLStencilRouteElement = (elm) => {\r\n    return elm.tagName === 'STENCIL-ROUTE';\r\n};\r\nexport class AnimatedRouteSwitch {\r\n    constructor() {\r\n        /** @internal */\r\n        this.group = getUniqueId();\r\n        this.subscribers = [];\r\n    }\r\n    componentWillLoad() {\r\n        if (this.location != null) {\r\n            this.regenerateSubscribers(this.location);\r\n        }\r\n        else {\r\n            console.warn(`<animated-route-switch> requires the \"location\" prop in order to be wired to Stencil Router.`);\r\n        }\r\n    }\r\n    async regenerateSubscribers(newLocation) {\r\n        console.log(newLocation);\r\n        if (newLocation == null) {\r\n            return;\r\n        }\r\n        let newActiveIndex = -1;\r\n        this.subscribers = Array.prototype.slice\r\n            .call(this.el.children)\r\n            .filter(isHTMLStencilRouteElement)\r\n            .map((childElement, index) => {\r\n            const match = getMatch(newLocation.pathname, childElement.url, childElement.exact);\r\n            if (match && newActiveIndex === -1) {\r\n                newActiveIndex = index;\r\n            }\r\n            return {\r\n                el: childElement,\r\n                match: match,\r\n            };\r\n        });\r\n        if (newActiveIndex === -1) {\r\n            return;\r\n        }\r\n        // Check if this actually changes which child is active\r\n        // then just pass the new match down if the active route isn't changing.\r\n        if (this.activeIndex === newActiveIndex) {\r\n            this.subscribers[newActiveIndex].el.match = this.subscribers[newActiveIndex].match;\r\n            return;\r\n        }\r\n        this.prevIndex = this.activeIndex;\r\n        this.activeIndex = newActiveIndex;\r\n        // Set all props on the new active route then wait until it says that it\r\n        // is completed\r\n        const prevChild = this.subscribers[this.prevIndex];\r\n        if (prevChild) {\r\n            await exitChildren(prevChild.el);\r\n        }\r\n        const activeChild = this.subscribers[this.activeIndex];\r\n        if (typeof this.scrollTopOffset === 'number') {\r\n            activeChild.el.scrollTopOffset = this.scrollTopOffset;\r\n        }\r\n        activeChild.el.group = this.group;\r\n        activeChild.el.match = activeChild.match;\r\n        activeChild.el.componentUpdated = (routeViewUpdatedOptions) => {\r\n            // After the new active route has completed then update visibility of routes\r\n            this.queue.write(() => {\r\n                this.subscribers.forEach((child, index) => {\r\n                    child.el.componentUpdated = undefined;\r\n                    if (index === this.activeIndex) {\r\n                        child.el.style.display = '';\r\n                        return enterChildren(child.el);\r\n                    }\r\n                    if (typeof this.scrollTopOffset === 'number') {\r\n                        child.el.scrollTopOffset = this.scrollTopOffset;\r\n                    }\r\n                    child.el.group = this.group;\r\n                    child.el.match = null;\r\n                    child.el.style.display = 'none';\r\n                });\r\n            });\r\n            if (this.routeViewsUpdated) {\r\n                this.routeViewsUpdated(Object.assign({ scrollTopOffset: this.scrollTopOffset }, routeViewUpdatedOptions));\r\n            }\r\n        };\r\n    }\r\n    render() {\r\n        return h(\"slot\", null);\r\n    }\r\n    static get is() { return \"animated-route-switch\"; }\r\n    static get properties() { return {\r\n        \"group\": {\r\n            \"type\": \"string\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"string\",\r\n                \"resolved\": \"string\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [{\r\n                        \"text\": undefined,\r\n                        \"name\": \"internal\"\r\n                    }],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"group\",\r\n            \"reflect\": true,\r\n            \"defaultValue\": \"getUniqueId()\"\r\n        },\r\n        \"routeViewsUpdated\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"(options: any) => void\",\r\n                \"resolved\": \"(options: any) => void\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [{\r\n                        \"text\": undefined,\r\n                        \"name\": \"internal\"\r\n                    }],\r\n                \"text\": \"\"\r\n            }\r\n        },\r\n        \"scrollTopOffset\": {\r\n            \"type\": \"number\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"number\",\r\n                \"resolved\": \"number\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"scroll-top-offset\",\r\n            \"reflect\": false\r\n        },\r\n        \"location\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"LocationSegments\",\r\n                \"resolved\": \"LocationSegments\",\r\n                \"references\": {\r\n                    \"LocationSegments\": {\r\n                        \"location\": \"import\",\r\n                        \"path\": \"../../utils/router\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            }\r\n        }\r\n    }; }\r\n    static get contextProps() { return [{\r\n            \"name\": \"queue\",\r\n            \"context\": \"queue\"\r\n        }]; }\r\n    static get elementRef() { return \"el\"; }\r\n    static get watchers() { return [{\r\n            \"propName\": \"location\",\r\n            \"methodName\": \"regenerateSubscribers\"\r\n        }]; }\r\n}\r\n"]}