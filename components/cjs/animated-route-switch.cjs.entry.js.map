{"file":"animated-route-switch.entry.cjs.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,iBAAiB,GAAG,GAAG,CAAC;AAC9B,MAAM,kBAAkB,GAAG,IAAI,CAAC;AAChC;AACA;AACA;AACA,MAAM,WAAW,GAAG,IAAI,MAAM,CAAC;AAC/B;AACA;AACA,IAAI,SAAS;AACb;AACA;AACA;AACA;AACA;AACA,IAAI,qFAAqF;AACzF,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;AAClB;AACA;AACA;AACO,MAAM,KAAK,GAAG,CAAC,GAAG,EAAE,OAAO,KAAK;AACvC,IAAI,IAAI,MAAM,GAAG,EAAE,CAAC;AACpB,IAAI,IAAI,GAAG,GAAG,CAAC,CAAC;AAChB,IAAI,IAAI,KAAK,GAAG,CAAC,CAAC;AAClB,IAAI,IAAI,IAAI,GAAG,EAAE,CAAC;AAClB,IAAI,IAAI,gBAAgB,GAAG,CAAC,OAAO,IAAI,OAAO,CAAC,SAAS,KAAK,iBAAiB,CAAC;AAC/E,IAAI,IAAI,UAAU,GAAG,CAAC,OAAO,IAAI,OAAO,CAAC,UAAU,KAAK,kBAAkB,CAAC;AAC3E,IAAI,IAAI,WAAW,GAAG,KAAK,CAAC;AAC5B,IAAI,IAAI,GAAG,CAAC;AACZ,IAAI,OAAO,CAAC,GAAG,GAAG,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,IAAI,EAAE;AACnD,QAAQ,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;AACvB,QAAQ,IAAI,OAAO,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7B,QAAQ,IAAI,MAAM,GAAG,GAAG,CAAC,KAAK,CAAC;AAC/B,QAAQ,IAAI,IAAI,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACzC,QAAQ,KAAK,GAAG,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC;AAClC;AACA,QAAQ,IAAI,OAAO,EAAE;AACrB,YAAY,IAAI,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC;AAC/B,YAAY,WAAW,GAAG,IAAI,CAAC;AAC/B,YAAY,SAAS;AACrB,SAAS;AACT,QAAQ,IAAI,IAAI,GAAG,EAAE,CAAC;AACtB,QAAQ,IAAI,IAAI,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC;AAC9B,QAAQ,IAAI,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;AAC1B,QAAQ,IAAI,OAAO,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7B,QAAQ,IAAI,KAAK,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3B,QAAQ,IAAI,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;AAC9B,QAAQ,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,MAAM,EAAE;AACzC,YAAY,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;AACpC,YAAY,IAAI,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;AAClD,gBAAgB,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AAC/B,gBAAgB,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACxC,aAAa;AACb,SAAS;AACT;AACA,QAAQ,IAAI,IAAI,EAAE;AAClB,YAAY,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC9B,YAAY,IAAI,GAAG,EAAE,CAAC;AACtB,YAAY,WAAW,GAAG,KAAK,CAAC;AAChC,SAAS;AACT,QAAQ,IAAI,OAAO,GAAG,IAAI,KAAK,EAAE,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,IAAI,CAAC;AACzE,QAAQ,IAAI,MAAM,GAAG,QAAQ,KAAK,GAAG,IAAI,QAAQ,KAAK,GAAG,CAAC;AAC1D,QAAQ,IAAI,QAAQ,GAAG,QAAQ,KAAK,GAAG,IAAI,QAAQ,KAAK,GAAG,CAAC;AAC5D,QAAQ,IAAI,SAAS,GAAG,IAAI,IAAI,gBAAgB,CAAC;AACjD,QAAQ,IAAI,OAAO,GAAG,OAAO,IAAI,KAAK,CAAC;AACvC,QAAQ,MAAM,CAAC,IAAI,CAAC;AACpB,YAAY,IAAI,EAAE,IAAI,IAAI,GAAG,EAAE;AAC/B,YAAY,MAAM,EAAE,IAAI;AACxB,YAAY,SAAS,EAAE,SAAS;AAChC,YAAY,QAAQ,EAAE,QAAQ;AAC9B,YAAY,MAAM,EAAE,MAAM;AAC1B,YAAY,OAAO,EAAE,OAAO;AAC5B,YAAY,OAAO,EAAE,OAAO;AAC5B,kBAAkB,WAAW,CAAC,OAAO,CAAC;AACtC,kBAAkB,IAAI,GAAG,YAAY,CAAC,SAAS,CAAC,GAAG,KAAK;AACxD,SAAS,CAAC,CAAC;AACX,KAAK;AACL;AACA,IAAI,IAAI,IAAI,IAAI,KAAK,GAAG,GAAG,CAAC,MAAM,EAAE;AACpC,QAAQ,MAAM,CAAC,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;AAC9C,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC,CAAC;AAmFF;AACA;AACA;AACA,MAAM,YAAY,GAAG,CAAC,GAAG,KAAK;AAC9B,IAAI,OAAO,GAAG,CAAC,OAAO,CAAC,2BAA2B,EAAE,MAAM,CAAC,CAAC;AAC5D,CAAC,CAAC;AACF;AACA;AACA;AACA,MAAM,WAAW,GAAG,CAAC,KAAK,KAAK;AAC/B,IAAI,OAAO,KAAK,CAAC,OAAO,CAAC,cAAc,EAAE,MAAM,CAAC,CAAC;AACjD,CAAC,CAAC;AACF;AACA;AACA;AACA,MAAM,KAAK,GAAG,CAAC,OAAO,KAAK;AAC3B,IAAI,OAAO,OAAO,IAAI,OAAO,CAAC,SAAS,GAAG,EAAE,GAAG,GAAG,CAAC;AACnD,CAAC,CAAC;AACF;AACA;AACA;AACA,MAAM,cAAc,GAAG,CAAC,IAAI,EAAE,IAAI,KAAK;AACvC,IAAI,IAAI,CAAC,IAAI;AACb,QAAQ,OAAO,IAAI,CAAC;AACpB;AACA,IAAI,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;AAChD,IAAI,IAAI,MAAM,EAAE;AAChB,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAChD,YAAY,IAAI,CAAC,IAAI,CAAC;AACtB,gBAAgB,IAAI,EAAE,CAAC;AACvB,gBAAgB,MAAM,EAAE,IAAI;AAC5B,gBAAgB,SAAS,EAAE,IAAI;AAC/B,gBAAgB,QAAQ,EAAE,KAAK;AAC/B,gBAAgB,MAAM,EAAE,KAAK;AAC7B,gBAAgB,OAAO,EAAE,KAAK;AAC9B,gBAAgB,OAAO,EAAE,IAAI;AAC7B,aAAa,CAAC,CAAC;AACf,SAAS;AACT,KAAK;AACL,IAAI,OAAO,IAAI,CAAC;AAChB,CAAC,CAAC;AACF;AACA;AACA;AACA,MAAM,aAAa,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,KAAK;AAC/C,IAAI,IAAI,KAAK,GAAG,EAAE,CAAC;AACnB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC1C,QAAQ,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC;AAChE,KAAK;AACL,IAAI,OAAO,IAAI,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;AACrE,CAAC,CAAC;AACF;AACA;AACA;AACA,MAAM,cAAc,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,KAAK;AAChD,IAAI,OAAO,cAAc,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;AAC/D,CAAC,CAAC;AACF;AACA;AACA;AACO,MAAM,cAAc,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,OAAO,KAAK;AACzD,IAAI,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;AAC5B,IAAI,IAAI,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;AAChC,IAAI,IAAI,GAAG,GAAG,OAAO,CAAC,GAAG,KAAK,KAAK,CAAC;AACpC,IAAI,IAAI,SAAS,GAAG,YAAY,CAAC,OAAO,CAAC,SAAS,IAAI,iBAAiB,CAAC,CAAC;AACzE,IAAI,IAAI,UAAU,GAAG,OAAO,CAAC,UAAU,IAAI,kBAAkB,CAAC;AAC9D,IAAI,IAAI,QAAQ,GAAG,EAAE;AACrB,SAAS,MAAM,CAAC,OAAO,CAAC,QAAQ,IAAI,EAAE,CAAC;AACvC,SAAS,GAAG,CAAC,YAAY,CAAC;AAC1B,SAAS,MAAM,CAAC,GAAG,CAAC;AACpB,SAAS,IAAI,CAAC,GAAG,CAAC,CAAC;AACnB,IAAI,IAAI,KAAK,GAAG,EAAE,CAAC;AACnB,IAAI,IAAI,cAAc,GAAG,KAAK,CAAC;AAC/B;AACA,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC5C,QAAQ,IAAI,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AAC9B,QAAQ,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;AACvC,YAAY,KAAK,IAAI,YAAY,CAAC,KAAK,CAAC,CAAC;AACzC,YAAY,cAAc;AAC1B,gBAAgB,CAAC,KAAK,MAAM,CAAC,MAAM,GAAG,CAAC;AACvC,oBAAoB,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AACrE,SAAS;AACT,aAAa;AACb,YAAY,IAAI,MAAM,GAAG,YAAY,CAAC,KAAK,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC;AAC1D,YAAY,IAAI,OAAO,GAAG,KAAK,CAAC,MAAM;AACtC,kBAAkB,KAAK;AACvB,oBAAoB,KAAK,CAAC,OAAO;AACjC,oBAAoB,MAAM;AAC1B,oBAAoB,MAAM;AAC1B,oBAAoB,KAAK;AACzB,oBAAoB,KAAK,CAAC,OAAO;AACjC,oBAAoB,KAAK;AACzB,kBAAkB,KAAK,CAAC,OAAO,CAAC;AAChC,YAAY,IAAI,IAAI;AACpB,gBAAgB,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACjC,YAAY,IAAI,KAAK,CAAC,QAAQ,EAAE;AAChC,gBAAgB,IAAI,KAAK,CAAC,OAAO,EAAE;AACnC,oBAAoB,KAAK,IAAI,MAAM,GAAG,GAAG,GAAG,OAAO,GAAG,IAAI,CAAC;AAC3D,iBAAiB;AACjB,qBAAqB;AACrB,oBAAoB,KAAK,IAAI,KAAK,GAAG,MAAM,GAAG,GAAG,GAAG,OAAO,GAAG,KAAK,CAAC;AACpE,iBAAiB;AACjB,aAAa;AACb,iBAAiB;AACjB,gBAAgB,KAAK,IAAI,MAAM,GAAG,GAAG,GAAG,OAAO,GAAG,GAAG,CAAC;AACtD,aAAa;AACb,SAAS;AACT,KAAK;AACL,IAAI,IAAI,GAAG,EAAE;AACb,QAAQ,IAAI,CAAC,MAAM;AACnB,YAAY,KAAK,IAAI,KAAK,GAAG,SAAS,GAAG,IAAI,CAAC;AAC9C,QAAQ,KAAK,IAAI,QAAQ,KAAK,GAAG,GAAG,GAAG,GAAG,KAAK,GAAG,QAAQ,GAAG,GAAG,CAAC;AACjE,KAAK;AACL,SAAS;AACT,QAAQ,IAAI,CAAC,MAAM;AACnB,YAAY,KAAK,IAAI,KAAK,GAAG,SAAS,GAAG,KAAK,GAAG,QAAQ,GAAG,KAAK,CAAC;AAClE,QAAQ,IAAI,CAAC,cAAc;AAC3B,YAAY,KAAK,IAAI,KAAK,GAAG,SAAS,GAAG,GAAG,GAAG,QAAQ,GAAG,GAAG,CAAC;AAC9D,KAAK;AACL,IAAI,OAAO,IAAI,MAAM,CAAC,GAAG,GAAG,KAAK,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;AACnD,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,YAAY,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,KAAK;AACrD,IAAI,IAAI,IAAI,YAAY,MAAM,EAAE;AAChC,QAAQ,OAAO,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC1C,KAAK;AACL,IAAI,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;AAC7B,QAAQ,OAAO,aAAa,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;AAClD,KAAK;AACL,IAAI,OAAO,cAAc,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;AAC/C,CAAC;;ACjTD,IAAI,UAAU,GAAG,CAAC,CAAC;AACnB,MAAM,YAAY,GAAG,EAAE,CAAC;AACxB,MAAM,UAAU,GAAG,KAAK,CAAC;AACzB;AACA,MAAM,WAAW,GAAG,CAAC,OAAO,EAAE,OAAO,KAAK;AAC1C,IAAI,MAAM,QAAQ,GAAG,CAAC,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;AACvD,IAAI,MAAM,KAAK,GAAG,YAAY,CAAC,QAAQ,CAAC,KAAK,YAAY,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC;AAC1E,IAAI,MAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;AACjD,IAAI,IAAI,KAAK,CAAC,YAAY,CAAC,EAAE;AAC7B,QAAQ,OAAO,KAAK,CAAC,YAAY,CAAC,CAAC;AACnC,KAAK;AACL,IAAI,MAAM,IAAI,GAAG,EAAE,CAAC;AACpB,IAAI,MAAM,EAAE,GAAG,YAAY,CAAC,OAAO,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;AACpD,IAAI,MAAM,eAAe,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC;AACzC,IAAI,IAAI,UAAU,GAAG,UAAU,EAAE;AACjC,QAAQ,KAAK,CAAC,YAAY,CAAC,GAAG,eAAe,CAAC;AAC9C,QAAQ,UAAU,IAAI,CAAC,CAAC;AACxB,KAAK;AACL,IAAI,OAAO,eAAe,CAAC;AAC3B,CAAC,CAAC;AACF;AACA;AACA;AACO,MAAM,SAAS,GAAG,CAAC,QAAQ,EAAE,OAAO,GAAG,EAAE,KAAK;AACrD,IAAI,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;AACrC,QAAQ,OAAO,GAAG,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC;AACpC,KAAK;AACL,IAAI,MAAM,EAAE,IAAI,GAAG,GAAG,EAAE,KAAK,GAAG,KAAK,EAAE,MAAM,GAAG,KAAK,EAAE,GAAG,OAAO,CAAC;AAClE,IAAI,MAAM,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,WAAW,CAAC,IAAI,EAAE,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC,CAAC;AACnE,IAAI,MAAM,KAAK,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AACpC,IAAI,IAAI,CAAC,KAAK,EAAE;AAChB,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,IAAI,MAAM,CAAC,GAAG,EAAE,GAAG,MAAM,CAAC,GAAG,KAAK,CAAC;AACnC,IAAI,MAAM,OAAO,GAAG,QAAQ,KAAK,GAAG,CAAC;AACrC,IAAI,IAAI,KAAK,IAAI,CAAC,OAAO,EAAE;AAC3B,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,IAAI,OAAO;AACX,QAAQ,IAAI;AACZ,QAAQ,GAAG,EAAE,IAAI,KAAK,GAAG,IAAI,GAAG,KAAK,EAAE,GAAG,GAAG,GAAG,GAAG;AACnD,QAAQ,OAAO;AACf,QAAQ,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,KAAK;AAClD,YAAY,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;AAC3C,YAAY,OAAO,IAAI,CAAC;AACxB,SAAS,EAAE,EAAE,CAAC;AACd,KAAK,CAAC;AACN,CAAC;;AC7CD,MAAM,WAAW,GAAG;EAChB,OAAO,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,KAAK,EAAE,QAAQ,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;AAC/E,CAAC,CAAC;AACF,MAAM,QAAQ,GAAG,CAAC,QAAQ,EAAE,GAAG,EAAE,KAAK;EAClC,OAAO,SAAS,CAAC,QAAQ,EAAE;IACvB,IAAI,EAAE,GAAG;IACT,KAAK,EAAE,KAAK;IACZ,MAAM,EAAE,IAAI;GACf,CAAC,CAAC;AACP,CAAC,CAAC;AACF,MAAM,yBAAyB,GAAG,CAAC,GAAG;EAClC,OAAO,GAAG,CAAC,OAAO,KAAK,eAAe,CAAC;AAC3C,CAAC,CAAC;MACW,mBAAmB;EAC5B;;;IAEI,IAAI,CAAC,KAAK,GAAG,WAAW,EAAE,CAAC;IAC3B,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;;GACzB;EACD,iBAAiB;IACb,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,EAAE;MACvB,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;KAC7C;SACI;MACD,OAAO,CAAC,IAAI,CAAC,8FAA8F,CAAC,CAAC;KAChH;GACJ;EACD,MAAM,qBAAqB,CAAC,WAAW;IACnC,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IACzB,IAAI,WAAW,IAAI,IAAI,EAAE;MACrB,OAAO;KACV;IACD,IAAI,cAAc,GAAG,CAAC,CAAC,CAAC;IACxB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK;OACnC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC;OACtB,MAAM,CAAC,yBAAyB,CAAC;OACjC,GAAG,CAAC,CAAC,YAAY,EAAE,KAAK;MACzB,MAAM,KAAK,GAAG,QAAQ,CAAC,WAAW,CAAC,QAAQ,EAAE,YAAY,CAAC,GAAG,EAAE,YAAY,CAAC,KAAK,CAAC,CAAC;MACnF,IAAI,KAAK,IAAI,cAAc,KAAK,CAAC,CAAC,EAAE;QAChC,cAAc,GAAG,KAAK,CAAC;OAC1B;MACD,OAAO;QACH,EAAE,EAAE,YAAY;QAChB,KAAK,EAAE,KAAK;OACf,CAAC;KACL,CAAC,CAAC;IACH,IAAI,cAAc,KAAK,CAAC,CAAC,EAAE;MACvB,OAAO;KACV;;;IAGD,IAAI,IAAI,CAAC,WAAW,KAAK,cAAc,EAAE;MACrC,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC,KAAK,CAAC;MACnF,OAAO;KACV;IACD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC;IAClC,IAAI,CAAC,WAAW,GAAG,cAAc,CAAC;;;IAGlC,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IACnD,IAAI,SAAS,EAAE;MACX,MAAMA,oBAAY,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;KACpC;IACD,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IACvD,IAAI,OAAO,IAAI,CAAC,eAAe,KAAK,QAAQ,EAAE;MAC1C,WAAW,CAAC,EAAE,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC;KACzD;IACD,WAAW,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;IAClC,WAAW,CAAC,EAAE,CAAC,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC;IACzC,WAAW,CAAC,EAAE,CAAC,gBAAgB,GAAG,CAAC,uBAAuB;;MAEtD,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC;QACb,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,KAAK;UAClC,KAAK,CAAC,EAAE,CAAC,gBAAgB,GAAG,SAAS,CAAC;UACtC,IAAI,KAAK,KAAK,IAAI,CAAC,WAAW,EAAE;YAC5B,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,GAAG,EAAE,CAAC;YAC5B,OAAOC,qBAAa,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;WAClC;UACD,IAAI,OAAO,IAAI,CAAC,eAAe,KAAK,QAAQ,EAAE;YAC1C,KAAK,CAAC,EAAE,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC;WACnD;UACD,KAAK,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;UAC5B,KAAK,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC;UACtB,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,GAAG,MAAM,CAAC;SACnC,CAAC,CAAC;OACN,CAAC,CAAC;MACH,IAAI,IAAI,CAAC,iBAAiB,EAAE;QACxB,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,eAAe,EAAE,IAAI,CAAC,eAAe,EAAE,EAAE,uBAAuB,CAAC,CAAC,CAAC;OAC7G;KACJ,CAAC;GACL;EACD,MAAM;IACF,OAAOC,OAAC,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;GAC1B;;;;;;;;;","names":["exitChildren","enterChildren","h"],"sources":["./node_modules/animate-presence/dist/collection/utils/path-to-regex.js","./node_modules/animate-presence/dist/collection/utils/router.js","./node_modules/animate-presence/dist/collection/components/animated-route-switch/animated-route-switch.js"],"sourcesContent":["/**\r\n * TS adaption of https://github.com/pillarjs/path-to-regexp/blob/master/index.js\r\n */\r\n/**\r\n * Default configs.\r\n */\r\nconst DEFAULT_DELIMITER = '/';\r\nconst DEFAULT_DELIMITERS = './';\r\n/**\r\n * The main path matching regexp utility.\r\n */\r\nconst PATH_REGEXP = new RegExp([\r\n    // Match escaped characters that would otherwise appear in future matches.\r\n    // This allows the user to escape special characters that won't transform.\r\n    '(\\\\\\\\.)',\r\n    // Match Express-style parameters and un-named parameters with a prefix\r\n    // and optional suffixes. Matches appear as:\r\n    //\r\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\r\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined]\r\n    '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?',\r\n].join('|'), 'g');\r\n/**\r\n * Parse a string for the raw tokens.\r\n */\r\nexport const parse = (str, options) => {\r\n    var tokens = [];\r\n    var key = 0;\r\n    var index = 0;\r\n    var path = '';\r\n    var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;\r\n    var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS;\r\n    var pathEscaped = false;\r\n    var res;\r\n    while ((res = PATH_REGEXP.exec(str)) !== null) {\r\n        var m = res[0];\r\n        var escaped = res[1];\r\n        var offset = res.index;\r\n        path += str.slice(index, offset);\r\n        index = offset + m.length;\r\n        // Ignore already escaped sequences.\r\n        if (escaped) {\r\n            path += escaped[1];\r\n            pathEscaped = true;\r\n            continue;\r\n        }\r\n        var prev = '';\r\n        var next = str[index];\r\n        var name = res[2];\r\n        var capture = res[3];\r\n        var group = res[4];\r\n        var modifier = res[5];\r\n        if (!pathEscaped && path.length) {\r\n            var k = path.length - 1;\r\n            if (delimiters.indexOf(path[k]) > -1) {\r\n                prev = path[k];\r\n                path = path.slice(0, k);\r\n            }\r\n        }\r\n        // Push the current path onto the tokens.\r\n        if (path) {\r\n            tokens.push(path);\r\n            path = '';\r\n            pathEscaped = false;\r\n        }\r\n        var partial = prev !== '' && next !== undefined && next !== prev;\r\n        var repeat = modifier === '+' || modifier === '*';\r\n        var optional = modifier === '?' || modifier === '*';\r\n        var delimiter = prev || defaultDelimiter;\r\n        var pattern = capture || group;\r\n        tokens.push({\r\n            name: name || key++,\r\n            prefix: prev,\r\n            delimiter: delimiter,\r\n            optional: optional,\r\n            repeat: repeat,\r\n            partial: partial,\r\n            pattern: pattern\r\n                ? escapeGroup(pattern)\r\n                : '[^' + escapeString(delimiter) + ']+?',\r\n        });\r\n    }\r\n    // Push any remaining characters.\r\n    if (path || index < str.length) {\r\n        tokens.push(path + str.substr(index));\r\n    }\r\n    return tokens;\r\n};\r\n/**\r\n * Compile a string to a template function for the path.\r\n */\r\nexport const compile = (str, options) => {\r\n    return tokensToFunction(parse(str, options));\r\n};\r\n/**\r\n * Expose a method for transforming tokens into the path function.\r\n */\r\nexport const tokensToFunction = (tokens) => {\r\n    // Compile all the tokens into regexps.\r\n    var matches = new Array(tokens.length);\r\n    // Compile all the patterns before compilation.\r\n    for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i];\r\n        if (typeof token === 'object') {\r\n            matches[i] = new RegExp('^(?:' + token.pattern + ')$');\r\n        }\r\n    }\r\n    return (data, options) => {\r\n        var path = '';\r\n        var encode = (options && options.encode) || encodeURIComponent;\r\n        for (var i = 0; i < tokens.length; i++) {\r\n            var token = tokens[i];\r\n            if (typeof token === 'string') {\r\n                path += token;\r\n                continue;\r\n            }\r\n            var value = data ? data[token.name] : undefined;\r\n            var segment;\r\n            if (Array.isArray(value)) {\r\n                if (!token.repeat) {\r\n                    throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array');\r\n                }\r\n                if (value.length === 0) {\r\n                    if (token.optional)\r\n                        continue;\r\n                    throw new TypeError('Expected \"' + token.name + '\" to not be empty');\r\n                }\r\n                for (var j = 0; j < value.length; j++) {\r\n                    segment = encode(value[j]);\r\n                    if (!matches[i].test(segment)) {\r\n                        throw new TypeError('Expected all \"' +\r\n                            token.name +\r\n                            '\" to match \"' +\r\n                            token.pattern +\r\n                            '\"');\r\n                    }\r\n                    path += (j === 0 ? token.prefix : token.delimiter) + segment;\r\n                }\r\n                continue;\r\n            }\r\n            if (typeof value === 'string' ||\r\n                typeof value === 'number' ||\r\n                typeof value === 'boolean') {\r\n                segment = encode(String(value));\r\n                if (!matches[i].test(segment)) {\r\n                    throw new TypeError('Expected \"' +\r\n                        token.name +\r\n                        '\" to match \"' +\r\n                        token.pattern +\r\n                        '\", but got \"' +\r\n                        segment +\r\n                        '\"');\r\n                }\r\n                path += token.prefix + segment;\r\n                continue;\r\n            }\r\n            if (token.optional) {\r\n                // Prepend partial segment prefixes.\r\n                if (token.partial)\r\n                    path += token.prefix;\r\n                continue;\r\n            }\r\n            throw new TypeError('Expected \"' +\r\n                token.name +\r\n                '\" to be ' +\r\n                (token.repeat ? 'an array' : 'a string'));\r\n        }\r\n        return path;\r\n    };\r\n};\r\n/**\r\n * Escape a regular expression string.\r\n */\r\nconst escapeString = (str) => {\r\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\r\n};\r\n/**\r\n * Escape the capturing group by escaping special characters and meaning.\r\n */\r\nconst escapeGroup = (group) => {\r\n    return group.replace(/([=!:$/()])/g, '\\\\$1');\r\n};\r\n/**\r\n * Get the flags for a regexp from the options.\r\n */\r\nconst flags = (options) => {\r\n    return options && options.sensitive ? '' : 'i';\r\n};\r\n/**\r\n * Pull out keys from a regexp.\r\n */\r\nconst regexpToRegexp = (path, keys) => {\r\n    if (!keys)\r\n        return path;\r\n    // Use a negative lookahead to match only capturing groups.\r\n    var groups = path.source.match(/\\((?!\\?)/g);\r\n    if (groups) {\r\n        for (var i = 0; i < groups.length; i++) {\r\n            keys.push({\r\n                name: i,\r\n                prefix: null,\r\n                delimiter: null,\r\n                optional: false,\r\n                repeat: false,\r\n                partial: false,\r\n                pattern: null,\r\n            });\r\n        }\r\n    }\r\n    return path;\r\n};\r\n/**\r\n * Transform an array into a regexp.\r\n */\r\nconst arrayToRegexp = (path, keys, options) => {\r\n    var parts = [];\r\n    for (var i = 0; i < path.length; i++) {\r\n        parts.push(pathToRegexp(path[i], keys, options).source);\r\n    }\r\n    return new RegExp('(?:' + parts.join('|') + ')', flags(options));\r\n};\r\n/**\r\n * Create a path regexp from string input.\r\n */\r\nconst stringToRegexp = (path, keys, options) => {\r\n    return tokensToRegExp(parse(path, options), keys, options);\r\n};\r\n/**\r\n * Expose a function for taking tokens and returning a RegExp.\r\n */\r\nexport const tokensToRegExp = (tokens, keys, options) => {\r\n    options = options || {};\r\n    var strict = options.strict;\r\n    var end = options.end !== false;\r\n    var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);\r\n    var delimiters = options.delimiters || DEFAULT_DELIMITERS;\r\n    var endsWith = []\r\n        .concat(options.endsWith || [])\r\n        .map(escapeString)\r\n        .concat('$')\r\n        .join('|');\r\n    var route = '';\r\n    var isEndDelimited = false;\r\n    // Iterate over the tokens and create our regexp string.\r\n    for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i];\r\n        if (typeof token === 'string') {\r\n            route += escapeString(token);\r\n            isEndDelimited =\r\n                i === tokens.length - 1 &&\r\n                    delimiters.indexOf(token[token.length - 1]) > -1;\r\n        }\r\n        else {\r\n            var prefix = escapeString(token.prefix || '');\r\n            var capture = token.repeat\r\n                ? '(?:' +\r\n                    token.pattern +\r\n                    ')(?:' +\r\n                    prefix +\r\n                    '(?:' +\r\n                    token.pattern +\r\n                    '))*'\r\n                : token.pattern;\r\n            if (keys)\r\n                keys.push(token);\r\n            if (token.optional) {\r\n                if (token.partial) {\r\n                    route += prefix + '(' + capture + ')?';\r\n                }\r\n                else {\r\n                    route += '(?:' + prefix + '(' + capture + '))?';\r\n                }\r\n            }\r\n            else {\r\n                route += prefix + '(' + capture + ')';\r\n            }\r\n        }\r\n    }\r\n    if (end) {\r\n        if (!strict)\r\n            route += '(?:' + delimiter + ')?';\r\n        route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';\r\n    }\r\n    else {\r\n        if (!strict)\r\n            route += '(?:' + delimiter + '(?=' + endsWith + '))?';\r\n        if (!isEndDelimited)\r\n            route += '(?=' + delimiter + '|' + endsWith + ')';\r\n    }\r\n    return new RegExp('^' + route, flags(options));\r\n};\r\n/**\r\n * Normalize the given path string, returning a regular expression.\r\n *\r\n * An empty array can be passed in for the keys, which will hold the\r\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\r\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\r\n */\r\nexport const pathToRegexp = (path, keys, options) => {\r\n    if (path instanceof RegExp) {\r\n        return regexpToRegexp(path, keys);\r\n    }\r\n    if (Array.isArray(path)) {\r\n        return arrayToRegexp(path, keys, options);\r\n    }\r\n    return stringToRegexp(path, keys, options);\r\n};\r\n","import { pathToRegexp } from './path-to-regex';\r\nlet cacheCount = 0;\r\nconst patternCache = {};\r\nconst cacheLimit = 10000;\r\n// Memoized function for creating the path match regex\r\nconst compilePath = (pattern, options) => {\r\n    const cacheKey = `${options.end}${options.strict}`;\r\n    const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\r\n    const cachePattern = JSON.stringify(pattern);\r\n    if (cache[cachePattern]) {\r\n        return cache[cachePattern];\r\n    }\r\n    const keys = [];\r\n    const re = pathToRegexp(pattern, keys, options);\r\n    const compiledPattern = { re, keys };\r\n    if (cacheCount < cacheLimit) {\r\n        cache[cachePattern] = compiledPattern;\r\n        cacheCount += 1;\r\n    }\r\n    return compiledPattern;\r\n};\r\n/**\r\n * Public API for matching a URL pathname to a path pattern.\r\n */\r\nexport const matchPath = (pathname, options = {}) => {\r\n    if (typeof options === 'string') {\r\n        options = { path: options };\r\n    }\r\n    const { path = '/', exact = false, strict = false } = options;\r\n    const { re, keys } = compilePath(path, { end: exact, strict });\r\n    const match = re.exec(pathname);\r\n    if (!match) {\r\n        return null;\r\n    }\r\n    const [url, ...values] = match;\r\n    const isExact = pathname === url;\r\n    if (exact && !isExact) {\r\n        return null;\r\n    }\r\n    return {\r\n        path,\r\n        url: path === '/' && url === '' ? '/' : url,\r\n        isExact,\r\n        params: keys.reduce((memo, key, index) => {\r\n            memo[key.name] = values[index];\r\n            return memo;\r\n        }, {}),\r\n    };\r\n};\r\n","import { h } from \"@stencil/core\";\r\nimport { matchPath } from '../../utils/router';\r\nimport { enterChildren, exitChildren } from '../../utils';\r\nconst getUniqueId = () => {\r\n    return ((Math.random() * 10e16).toString().match(/.{4}/g) || []).join('-');\r\n};\r\nconst getMatch = (pathname, url, exact) => {\r\n    return matchPath(pathname, {\r\n        path: url,\r\n        exact: exact,\r\n        strict: true,\r\n    });\r\n};\r\nconst isHTMLStencilRouteElement = (elm) => {\r\n    return elm.tagName === 'STENCIL-ROUTE';\r\n};\r\nexport class AnimatedRouteSwitch {\r\n    constructor() {\r\n        /** @internal */\r\n        this.group = getUniqueId();\r\n        this.subscribers = [];\r\n    }\r\n    componentWillLoad() {\r\n        if (this.location != null) {\r\n            this.regenerateSubscribers(this.location);\r\n        }\r\n        else {\r\n            console.warn(`<animated-route-switch> requires the \"location\" prop in order to be wired to Stencil Router.`);\r\n        }\r\n    }\r\n    async regenerateSubscribers(newLocation) {\r\n        console.log(newLocation);\r\n        if (newLocation == null) {\r\n            return;\r\n        }\r\n        let newActiveIndex = -1;\r\n        this.subscribers = Array.prototype.slice\r\n            .call(this.el.children)\r\n            .filter(isHTMLStencilRouteElement)\r\n            .map((childElement, index) => {\r\n            const match = getMatch(newLocation.pathname, childElement.url, childElement.exact);\r\n            if (match && newActiveIndex === -1) {\r\n                newActiveIndex = index;\r\n            }\r\n            return {\r\n                el: childElement,\r\n                match: match,\r\n            };\r\n        });\r\n        if (newActiveIndex === -1) {\r\n            return;\r\n        }\r\n        // Check if this actually changes which child is active\r\n        // then just pass the new match down if the active route isn't changing.\r\n        if (this.activeIndex === newActiveIndex) {\r\n            this.subscribers[newActiveIndex].el.match = this.subscribers[newActiveIndex].match;\r\n            return;\r\n        }\r\n        this.prevIndex = this.activeIndex;\r\n        this.activeIndex = newActiveIndex;\r\n        // Set all props on the new active route then wait until it says that it\r\n        // is completed\r\n        const prevChild = this.subscribers[this.prevIndex];\r\n        if (prevChild) {\r\n            await exitChildren(prevChild.el);\r\n        }\r\n        const activeChild = this.subscribers[this.activeIndex];\r\n        if (typeof this.scrollTopOffset === 'number') {\r\n            activeChild.el.scrollTopOffset = this.scrollTopOffset;\r\n        }\r\n        activeChild.el.group = this.group;\r\n        activeChild.el.match = activeChild.match;\r\n        activeChild.el.componentUpdated = (routeViewUpdatedOptions) => {\r\n            // After the new active route has completed then update visibility of routes\r\n            this.queue.write(() => {\r\n                this.subscribers.forEach((child, index) => {\r\n                    child.el.componentUpdated = undefined;\r\n                    if (index === this.activeIndex) {\r\n                        child.el.style.display = '';\r\n                        return enterChildren(child.el);\r\n                    }\r\n                    if (typeof this.scrollTopOffset === 'number') {\r\n                        child.el.scrollTopOffset = this.scrollTopOffset;\r\n                    }\r\n                    child.el.group = this.group;\r\n                    child.el.match = null;\r\n                    child.el.style.display = 'none';\r\n                });\r\n            });\r\n            if (this.routeViewsUpdated) {\r\n                this.routeViewsUpdated(Object.assign({ scrollTopOffset: this.scrollTopOffset }, routeViewUpdatedOptions));\r\n            }\r\n        };\r\n    }\r\n    render() {\r\n        return h(\"slot\", null);\r\n    }\r\n    static get is() { return \"animated-route-switch\"; }\r\n    static get properties() { return {\r\n        \"group\": {\r\n            \"type\": \"string\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"string\",\r\n                \"resolved\": \"string\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [{\r\n                        \"text\": undefined,\r\n                        \"name\": \"internal\"\r\n                    }],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"group\",\r\n            \"reflect\": true,\r\n            \"defaultValue\": \"getUniqueId()\"\r\n        },\r\n        \"routeViewsUpdated\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"(options: any) => void\",\r\n                \"resolved\": \"(options: any) => void\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [{\r\n                        \"text\": undefined,\r\n                        \"name\": \"internal\"\r\n                    }],\r\n                \"text\": \"\"\r\n            }\r\n        },\r\n        \"scrollTopOffset\": {\r\n            \"type\": \"number\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"number\",\r\n                \"resolved\": \"number\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"scroll-top-offset\",\r\n            \"reflect\": false\r\n        },\r\n        \"location\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"LocationSegments\",\r\n                \"resolved\": \"LocationSegments\",\r\n                \"references\": {\r\n                    \"LocationSegments\": {\r\n                        \"location\": \"import\",\r\n                        \"path\": \"../../utils/router\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            }\r\n        }\r\n    }; }\r\n    static get contextProps() { return [{\r\n            \"name\": \"queue\",\r\n            \"context\": \"queue\"\r\n        }]; }\r\n    static get elementRef() { return \"el\"; }\r\n    static get watchers() { return [{\r\n            \"propName\": \"location\",\r\n            \"methodName\": \"regenerateSubscribers\"\r\n        }]; }\r\n}\r\n"],"version":3}