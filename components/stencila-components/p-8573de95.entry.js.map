{"version":3,"sources":["src/components/codeChunk/codeChunk.css?tag=stencila-code-chunk&mode=default&encapsulation=scoped","src/components/codeChunk/codeChunk.material.css?tag=stencila-code-chunk&mode=material&encapsulation=scoped","src/components/codeChunk/codeChunk.tsx"],"names":["defaultCodeChunkCss","codeChunkMaterialCss","CodeChunkComponent","[object Object]","hostRef","this","autofocus","languageCapabilities","fileFormatMap","isExecutable","isCodeVisible","shiftIsPressed","keymap","isStacked","toggleCodeVisibility","e","preventDefault","shiftKey","allCodeVisibilityChange","emit","isVisible","checkIfExecutable","programmingLanguage","undefined","Object","keys","_a","executableLanguages","length","activeLanguageFormat","lookupFormat","name","values","_b","some","format","handleLanguageChange","detail","editorLayoutChangeHandler","toggleEditorLayout","editorLayoutChange","onExecuteHandler","async","ordering","node","getContents","isPending","executeStatus","codeExecuteCancelEvent","nodeId","el","id","scope","codeExecuteEvent","executeHandler","computed","onKeyPress","addKeyListeners","window","addEventListener","removeKeyListeners","removeEventListener","languages","event","editorRef","text","language","makeCodeChunk","Error","res","err","console","error","getRef","minWidth","getBoundingClientRect","width","h","Host","class","menuPosition","slot","CodeExecuteStatus","executeRequired","icon","minimal","color","size","tooltip","iconOnly","onClick","execute","onMouseEnter","onMouseLeave","editorContainer","hidden","activeLanguage","readOnly","onStencila-language-change","ref","slots","errors","outputs","label","caption"],"mappings":"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","sourcesContent":["@import '~@stencila/style-stencila/dist/molecules/codeChunk.css';\n","@import '~@stencila/style-stencila/dist/molecules/codeChunk.css';\n","import { EditorView } from '@codemirror/view'\nimport {\n  Component,\n  Element,\n  Event,\n  EventEmitter,\n  h,\n  Host,\n  Listen,\n  Method,\n  Prop,\n  State,\n} from '@stencil/core'\nimport { CodeChunk, codeChunk as makeCodeChunk } from '@stencila/schema'\nimport { CodeExecuteStatus } from '../code/codeExecuteStatus'\nimport {\n  CodeComponent,\n  CodeExecuteCancelEvent,\n  CodeExecuteEvent,\n  CodeExecuteOrdering,\n  CodeVisibilityEvent,\n  DiscoverExecutableLanguagesEvent,\n  ExecuteRequired,\n  ExecuteStatus,\n} from '../code/codeTypes'\nimport { isPending } from '../code/codeUtils'\nimport { EditorUpdateHandlerCb } from '../editor/customizations/onUpdateHandlerExtension'\nimport { Keymap } from '../editor/editor'\nimport {\n  FileFormat,\n  fileFormatMap,\n  FileFormatMap,\n  lookupFormat,\n} from '../editor/languageUtils'\n\n/**\n * @slot text - The source code of the `CodeChunk`. Corresponds to the `text` field in the Stencila `CodeChunk` Schema.\n * @slot outputs - The resulting output when evaluating the CodeChunk. Corresponds to the `outputs` field in the Stencila `CodeChunk` Schema.\n * @slot errors - List of any errors encountered when compiling (e.g. syntax errors) or executing the CodeChunk.\n * @slot label - `label` element label of the `CodeChunk`. Corresponds to the `label` field in the Stencila `CodeChunk` Schema.\n * @slot caption - `figcaption` content of the `CodeChunk`. Corresponds to the `caption` field in the Stencila `CodeChunk` Schema.\n */\n@Component({\n  tag: 'stencila-code-chunk',\n  styleUrls: {\n    default: 'codeChunk.css',\n    material: 'codeChunk.material.css',\n  },\n  scoped: true,\n})\nexport class CodeChunkComponent implements CodeComponent<CodeChunk> {\n  private static readonly slots = {\n    text: 'text',\n    outputs: 'outputs',\n    errors: 'errors',\n    caption: 'caption',\n    label: 'label',\n  }\n\n  @Element() private el: HTMLStencilaCodeChunkElement\n\n  public editorRef: HTMLStencilaEditorElement | undefined\n\n  /**\n   * Source code contents of the CodeChunk.\n   * Corresponds to the `text` property of the CodeChunk schema.\n   */\n  @Prop()\n  public text?: string\n\n  /**\n   * Autofocus the editor on page load\n   */\n  @Prop() public autofocus = false\n\n  /**\n   * Programming language of the CodeChunk\n   */\n  @Prop({ mutable: true })\n  public programmingLanguage: string | undefined\n\n  /**\n   * List of all supported programming languages\n   */\n  @Prop()\n  public languageCapabilities: FileFormatMap = fileFormatMap\n\n  /**\n   * List of programming languages that can be executed in the current context\n   */\n  @Prop()\n  public executableLanguages?: FileFormatMap\n\n  @Listen('stencila-discover-executable-languages', { target: 'window' })\n  onDiscoverExecutableLanguages({\n    detail,\n  }: DiscoverExecutableLanguagesEvent): void {\n    this.executableLanguages = detail.languages\n    this.checkIfExecutable()\n  }\n\n  @State() isExecutable = false\n\n  /**\n   * Whether the code section is visible or not\n   */\n  @Prop({ mutable: true })\n  public isCodeVisible = false\n\n  /**\n   * A callback function to be called with the value of the `CodeChunk` node when executing the `CodeChunk`.\n   */\n  @Prop()\n  public executeHandler?: (codeChunk: CodeChunk) => Promise<CodeChunk>\n\n  @State()\n  shiftIsPressed = false\n\n  /**\n   * Emitted to indicate that code node should be executed\n   *\n   */\n  @Event({\n    eventName: 'stencila-code-execute',\n  })\n  public codeExecuteEvent: EventEmitter<CodeExecuteEvent['detail']>\n\n  /**\n   * Emitted to indicate that the execution of the code node should be cancelled/interrupted.\n   */\n  @Event({\n    eventName: 'stencila-code-execute-cancel',\n  })\n  public codeExecuteCancelEvent: EventEmitter<CodeExecuteCancelEvent['detail']>\n\n  /**\n   * Callback function to invoke whenever the editor contents are updated.\n   */\n  @Prop()\n  public contentChangeHandler?: EditorUpdateHandlerCb\n\n  /**\n   * The execution status of the code node\n   */\n  @Prop()\n  executeStatus: ExecuteStatus\n\n  /**\n   * A digest representing the state of a [`Resource`] and its dependencies at\n   * compile time.\n   */\n  @Prop()\n  compileDigest: string\n\n  /**\n   * Status of upstream dependencies, and whether the node needs to be\n   * re-executed\n   */\n  @Prop()\n  executeRequired: ExecuteRequired\n\n  /**\n   * A digest representing the state of a [`Resource`] and its dependencies from\n   * the latest execution.\n   */\n  @Prop()\n  executeDigest: string\n\n  /**\n   * Time when the latest code execution ended\n   */\n  @Prop()\n  executeEnded: string\n\n  /**\n   * Duration of the latest code execition\n   */\n  @Prop()\n  executeDuration: string\n\n  /**\n   * Custom keyboard shortcuts to pass along to CodeMirror\n   * @see https://codemirror.net/6/docs/ref/#keymap\n   */\n  @Prop() public keymap: Keymap[] = []\n\n  @State() isStacked = true\n\n  /**\n   * A global event emitter to show/hide code in all `CodeChunk` or `CodeExpression` components\n   */\n  @Event({\n    eventName: 'stencila-code-visibility-change',\n  })\n  allCodeVisibilityChange: EventEmitter\n\n  /**\n   * A global event listener to show/hide code in this component\n   */\n  @Listen('stencila-code-visibility-change', { target: 'window' })\n  onAllCodeVisibilityChange(event: CodeVisibilityEvent): void {\n    this.isCodeVisible = event.detail.isVisible\n  }\n\n  /**\n   * Toggle code visibility, either locally, or globally\n   */\n  private toggleCodeVisibility = (e: MouseEvent): void => {\n    e.preventDefault()\n    if (e.shiftKey) {\n      this.allCodeVisibilityChange.emit({ isVisible: !this.isCodeVisible })\n    } else {\n      this.isCodeVisible = !this.isCodeVisible\n    }\n  }\n\n  /**\n   * Determine if the CodeChunk can be executed or not.\n   * For a CodeChunk to be considered executable it must have a `executeHandler` function attached\n   * and the current `programmingLanguage` must be in the list of `executableLanguages`.\n   */\n  private checkIfExecutable = (): void => {\n    if (\n      this.programmingLanguage === undefined ||\n      Object.keys(this.executableLanguages ?? {}).length <= 0\n    ) {\n      this.isExecutable = false\n      return\n    }\n\n    const activeLanguageFormat = lookupFormat(this.programmingLanguage).name\n    this.isExecutable = Object.values(this.executableLanguages ?? {}).some(\n      (format) => format.name === activeLanguageFormat\n    )\n  }\n\n  /**\n   * Listen for the `stencila-language-change` event emitted by the language dropdown\n   * provided by the child Editor component, and update the active language if necessary.\n   */\n  private handleLanguageChange = (e: CustomEvent<FileFormat>) => {\n    if (\n      this.programmingLanguage === undefined ||\n      lookupFormat(this.programmingLanguage).name !== e.detail.name\n    ) {\n      this.programmingLanguage = e.detail.name\n    }\n  }\n\n  private editorLayoutChangeHandler = (isStacked: boolean) => {\n    this.isStacked = isStacked\n  }\n\n  /**\n   * Trigger a global DOM event to set the layout of all `CodeChunk` component.\n   * Can be set to either show the editor and outputs side by side or stacked vertically.\n   */\n  @Event({\n    eventName: 'stencila-editor-layout-change',\n  })\n  public editorLayoutChange: EventEmitter\n\n  @Listen('stencila-editor-layout-change', { target: 'window' })\n  onSetEditorLayout(event: { detail: { isStacked: boolean } }): void {\n    this.editorLayoutChangeHandler(event.detail.isStacked)\n  }\n\n  private toggleEditorLayout = (e: MouseEvent) => {\n    e.preventDefault()\n    if (e.shiftKey) {\n      this.editorLayoutChange.emit({ isStacked: !this.isStacked })\n    } else {\n      this.editorLayoutChangeHandler(!this.isStacked)\n    }\n  }\n\n  /**\n   * Returns the `CodeChunk` node with the updated `text` content from the editor.\n   */\n  @Method()\n  public async getContents(): Promise<CodeChunk> {\n    if (this.editorRef) {\n      const { text, language } = await this.editorRef?.getContents()\n      return makeCodeChunk({ text, programmingLanguage: language })\n    }\n\n    throw new Error('Could not get CodeChunk contents')\n  }\n\n  /**\n   * Returns the text contents from the editor\n   */\n  @Method()\n  public async getTextContents(): Promise<string> {\n    if (this.editorRef) {\n      const { text } = await this.editorRef?.getContents()\n      return text\n    }\n\n    throw new Error('Could not get CodeChunk contents')\n  }\n\n  private onExecuteHandler = async (\n    ordering: CodeExecuteOrdering = 'Topological'\n  ): Promise<CodeChunk> => {\n    const node = await this.getContents()\n\n    // If node is running, emit cancel event and terminate early\n    if (isPending(this.executeStatus)) {\n      this.codeExecuteCancelEvent.emit({\n        nodeId: this.el.id,\n        scope: 'All',\n      })\n      return node\n    }\n\n    this.codeExecuteEvent.emit({\n      nodeId: this.el.id,\n      ordering,\n    })\n\n    if (this.isExecutable && this.executeHandler) {\n      const computed = await this.executeHandler(node)\n      return computed\n    }\n\n    return node\n  }\n\n  /**\n   * Run the `CodeChunk`\n   */\n  @Method()\n  public async execute(\n    ordering: CodeExecuteOrdering = 'Topological'\n  ): Promise<CodeChunk | Error> {\n    try {\n      const res = await this.onExecuteHandler(ordering)\n      // Add artificial delay to allow user to register the spinner\n      return res\n    } catch (err) {\n      console.error(err)\n      return new Error('Could not execute CodeChunk')\n    }\n  }\n\n  /**\n   * Retrieve a reference to the internal CodeMirror editor.\n   * Allows for maintaining state from applications making use of this component.\n   */\n  @Method()\n  public async getRef(): Promise<EditorView | undefined> {\n    return this.editorRef?.getRef()\n  }\n\n  private onKeyPress = (e: KeyboardEvent): void => {\n    this.shiftIsPressed = e.shiftKey\n  }\n\n  private addKeyListeners = () => {\n    window.addEventListener('keydown', this.onKeyPress)\n    window.addEventListener('keyup', this.onKeyPress)\n  }\n\n  private removeKeyListeners = () => {\n    window.removeEventListener('keydown', this.onKeyPress)\n    window.removeEventListener('keyup', this.onKeyPress)\n    this.shiftIsPressed = false\n  }\n\n  componentWillLoad(): void {\n    /** Get rendered width of component to decide whether to stack the editor and outputs or not.\n     * We can’t use media queries as the component is not always full width of the viewport, and depends on the parent element width.\n     */\n    const minWidth = 1200 // A non-scientific value below which the side-by-side layout looks too narrow.\n    this.isStacked = this.el.getBoundingClientRect().width < minWidth\n\n    this.checkIfExecutable()\n  }\n\n  public render(): HTMLElement {\n    return (\n      <Host\n        class={{\n          isCodeVisible: this.isCodeVisible,\n          isStacked: this.isStacked,\n        }}\n      >\n        <figure>\n          <stencila-action-menu>\n            <stencila-menu menuPosition=\"bottom-start\" slot=\"persistentActions\">\n              <CodeExecuteStatus\n                executeStatus={this.executeStatus}\n                executeRequired={this.executeRequired}\n                slot=\"toggle\"\n              ></CodeExecuteStatus>\n              <slot name=\"code-dependencies\"></slot>\n              <slot name=\"code-dependents\"></slot>\n            </stencila-menu>\n            {this.isExecutable && (\n              <stencila-button\n                icon={isPending(this.executeStatus) ? 'stop' : 'play'}\n                minimal={true}\n                color=\"key\"\n                class=\"run\"\n                size=\"xsmall\"\n                tooltip={\n                  isPending(this.executeStatus)\n                    ? 'Cancel'\n                    : this.shiftIsPressed\n                    ? 'Run only this code'\n                    : 'Run'\n                }\n                iconOnly={true}\n                slot=\"persistentActions\"\n                onClick={(e) =>\n                  this.execute(e.shiftKey ? 'Single' : 'Topological')\n                }\n                onMouseEnter={this.addKeyListeners}\n                onMouseLeave={this.removeKeyListeners}\n              ></stencila-button>\n            )}\n            <stencila-button\n              minimal={true}\n              color=\"key\"\n              class=\"sourceToggle\"\n              onClick={this.toggleCodeVisibility}\n              icon={this.isCodeVisible ? 'eye-off' : 'eye'}\n              iconOnly={true}\n              size=\"xsmall\"\n              slot=\"persistentActions\"\n              tooltip={`${\n                this.isCodeVisible ? 'Hide' : 'Show'\n              } Code\\nShift click to set for all code`}\n            ></stencila-button>\n            )\n            {this.isCodeVisible && (\n              <stencila-button\n                minimal={true}\n                color=\"key\"\n                class=\"layoutToggle\"\n                onClick={this.toggleEditorLayout}\n                icon={this.isStacked ? 'layout-column' : 'layout-row'}\n                iconOnly={true}\n                size=\"xsmall\"\n                slot=\"persistentActions\"\n                tooltip={`${\n                  this.isStacked ? 'Side by side' : 'Stacked'\n                } view\\nShift click to set for all code`}\n              ></stencila-button>\n            )}\n          </stencila-action-menu>\n\n          <div>\n            <div\n              class={{\n                editorContainer: true,\n                hidden: !this.isCodeVisible,\n              }}\n            >\n              <stencila-editor\n                activeLanguage={this.programmingLanguage}\n                executableLanguages={this.executableLanguages}\n                autofocus={this.autofocus}\n                executeHandler={() => this.onExecuteHandler()}\n                keymap={this.keymap}\n                readOnly={!this.isExecutable}\n                onStencila-language-change={this.handleLanguageChange}\n                ref={(el) => {\n                  this.editorRef = el\n                }}\n              >\n                <slot name={CodeChunkComponent.slots.text} />\n                <slot name={CodeChunkComponent.slots.errors} />\n              </stencila-editor>\n            </div>\n\n            <slot name={CodeChunkComponent.slots.outputs} />\n          </div>\n\n          <slot name={CodeChunkComponent.slots.label} />\n\n          <slot name={CodeChunkComponent.slots.caption} />\n        </figure>\n      </Host>\n    )\n  }\n}\n"]}