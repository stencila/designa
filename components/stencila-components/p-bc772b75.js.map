{"version":3,"sources":["node_modules/@lezer/markdown/dist/index.js","node_modules/@codemirror/lang-markdown/dist/index.js"],"names":["CompositeBlock","[object Object]","type","value","from","hash","end","children","positions","this","hashProp","NodeProp","contextHash","parentHash","child","pos","prop","Tree","length","push","nodeSet","last","Math","max","tree","types","balance","makeTree","NodeType","none","Type","LeafBlock","start","content","marks","parsers","Line","text","baseIndent","basePos","depth","markers","indent","next","forwardInner","newPos","skipSpace","countIndent","charCodeAt","pop","to","findColumn","elt","i","goal","result","slice","skipForList","bl","cx","line","block","stack","size","OrderedList","isOrderedList","isBulletList","BulletList","isHorizontalRule","DefaultSkipMarkup","Blockquote","QuoteMark","lineStart","moveBase","space","ListItem","_cx","moveBaseColumn","Document","ch","skipSpaceBack","isFencedCode","isBlockquote","breaking","count","isSetextUnderline","inList","isAtxHeading","EmptyLine","CommentEnd","ProcessingEnd","HTMLBlockStyle","isHTMLBlock","rest","e","test","getListIndent","indentAfter","indented","addCodeText","CodeText","DefaultBlockParsers","LinkReference","undefined","base","pendingMarks","nextLine","m","codeStart","filter","concat","addNode","buffer","writeElements","finish","CodeBlock","fenceEnd","len","infoFrom","infoTo","CodeMark","CodeInfo","first","textStart","textEnd","FencedCode","prevLineEnd","startContext","HorizontalRule","newBase","ListMark","off","endOfSpace","after","buf","write","HeaderMark","parser","parseInline","node","ATXHeading1","trailing","nodeType","CommentBlock","ProcessingInstructionBlock","HTMLBlock","SetextHeading","LinkReferenceParser","leaf","stage","elts","advance","scrub","complete","addLeafElement","nextStage","parseLinkLabel","LinkMark","parseURL","skip","title","parseLinkTitle","titleEnd","lineEnd","SetextHeadingParser","underline","underlineMark","SetextHeading1","SetextHeading2","DefaultLeafBlocks","_","DefaultEndLeaf","p","scanLineResult","BlockContext","input","fragments","ranges","atEnd","dontInject","Set","stoppedAt","rangeI","absoluteLineStart","absoluteLineEnd","create","FragmentCursor","readLine","parsedPos","finishContext","mark","reuseFragment","blockParsers","forward","parse","leafBlockParsers","lines","stop","endLeafBlock","finishLeaf","RangeError","moveTo","matches","taken","takeNodes","withoutGaps","gapFrom","gapTo","moveRangeI","r","lineChunkAt","textOffset","nextFrom","scanLine","reset","handler","skipContextMarkup","Error","chunk","lineChunks","eol","indexOf","getNodeType","addChild","toTree","injectMarks","top","addGaps","injectGaps","topNode","inline","Paragraph","TreeElement","Buffer","offset","dont","has","rangeEnd","movePastNext","upto","inclusive","firstChild","nextSibling","propValues","MarkdownParser","Parser","blockNames","inlineParsers","inlineNames","wrappers","super","nodeTypes","Object","t","name","id","w","spec","config","resolveConfig","nonEmpty","defineNodes","assign","s","composite","some","group","define","props","NodeSet","extend","remove","rm","parseBlock","found","before","findName","splice","endLeaf","wrap","InlineContext","outer","char","token","resolveMarkers","a","Array","isArray","conf","conc","b","wrapA","wrapB","inner","names","Escape","nodes","writeTo","build","reused","topID","Element","startOff","EmphasisUnderscore","resolve","EmphasisAsterisk","LinkStart","ImageStart","InlineDelimiter","side","Escapable","Punctuation","RegExp","DefaultInline","escaped","append","exec","Entity","curSize","InlineCode","url","URL","comment","Comment","procInst","ProcessingInstruction","HTMLTag","pBefore","pAfter","sBefore","sAfter","leftFlanking","rightFlanking","canOpen","canClose","HardBreak","parts","part","takeContent","link","finishLink","Link","Image","j","startPos","endPos","unshift","dest","label","LinkTitle","requireNonWS","min","LinkLabel","open","close","emp","closeSize","k","element","keep","startIndex","elements","eI","NotLast","fragment","fragmentEnd","cursor","nextFragment","read","c","rPos","parent","childAfter","cur","fragEnd","openEnd","blockI","prevEnd","prevI","isAnonymous","add","is","keys","map","n","leftOverSpace","nextPos","parseCode","codeParser","htmlParser","parseMixed","info","infoNode","getChild","overlay","StrikethroughDelim","Strikethrough","addDelimiter","parseRow","startI","cellStart","cellEnd","esc","parseCell","hasPipe","str","delimiterLine","TableParser","rows","lineText","firstRow","firstCount","Table","TaskParser","TaskList","parentType","GFM","parseSubSuper","addElement","Superscript","Subscript","Emoji","match","data","defineLanguageFacet","commonmark","configure","styleTags","Blockquote/...","tags","quote","contentSeparator","ATXHeading1/... SetextHeading1/...","heading1","ATXHeading2/... SetextHeading2/...","heading2","ATXHeading3/...","heading3","ATXHeading4/...","heading4","ATXHeading5/...","heading5","ATXHeading6/...","heading6","Comment CommentBlock","escape","character","Emphasis/...","emphasis","StrongEmphasis/...","strong","Link/... Image/...","OrderedList/... BulletList/...","list","BlockQuote/...","InlineCode CodeText","monospace","HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark","processingInstruction","CodeInfo LinkLabel","labelName","string","foldNodeProp","state","doc","lineAt","indentNodeProp","languageDataProp","mkLang","Language","find","commonmarkLanguage","extended","TableDelimiter SubscriptMark SuperscriptMark StrikethroughMark","TableHeader/...","heading","Strikethrough/...","strikethrough","TaskMarker","atom","Task","Subscript Superscript","special","TableCell","markdownLanguage","getCodeParser","languages","defaultLanguage","LanguageDescription","matchLanguageName","support","language","ParseContext","getSkippingParser","load","nodeStart","sliceString","Context","spaceBefore","spaceAfter","item","number","String","itemNumber","getContext","context","renumberList","changes","prev","insert","insertNewlineContinueMarkup","dispatch","syntaxTree","changeByRange","range","empty","isActiveAt","resolveInner","emptyLine","delTo","marker","EditorSelection","blank","lineBreak","prevLine","quoted","index","continued","charAt","update","scrollIntoView","userEvent","isMark","contextNodeForDelete","scan","childBefore","lastChild","deleteMarkupBackward","spaceEnd","markdownKeymap","key","run","htmlNoMatch","html","matchClosingTags","markdown","codeLanguages","defaultCodeLanguage","addKeymap","extensions","defaultCode","LanguageSupport","Prec","high","keymap","of"],"mappings":"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","sourcesContent":["import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\n\nclass CompositeBlock {\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        let tree = new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n        return tree;\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"URL\"] = 33] = \"URL\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n})(Type || (Type = {}));\n/// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\nclass LeafBlock {\n    /// @internal\n    constructor(\n    /// The start position of the block.\n    start, \n    /// The block's text content.\n    content) {\n        this.start = start;\n        this.content = content;\n        /// @internal\n        this.marks = [];\n        /// The block parsers active for this block.\n        this.parsers = [];\n    }\n}\n/// Data structure used during block-level per-line parsing.\nclass Line {\n    constructor() {\n        /// The line's full text.\n        this.text = \"\";\n        /// The base indent provided by the composite contexts (that have\n        /// been handled so far).\n        this.baseIndent = 0;\n        /// The string position corresponding to the base indent.\n        this.basePos = 0;\n        /// The number of contexts handled @internal\n        this.depth = 0;\n        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        this.markers = [];\n        /// The position of the next non-whitespace character beyond any\n        /// list, blockquote, or other composite block markers.\n        this.pos = 0;\n        /// The column of the next non-whitespace character.\n        this.indent = 0;\n        /// The character code of the character after `pos`.\n        this.next = -1;\n    }\n    /// @internal\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /// @internal\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /// Skip whitespace after the given position, return the position of\n    /// the next non-space character or the end of the line if there's\n    /// only space after `from`.\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /// @internal\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /// Move the line's base position forward to the given position.\n    /// This should only be called by composite [block\n    /// parsers](#BlockParser.parse) or [markup skipping\n    /// functions](#NodeSpec.composite).\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /// Move the line's base position forward to the given _column_.\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /// Store a composite-block-level marker. Should be called from\n    /// [markup skipping functions](#NodeSpec.composite) when they\n    /// consume any non-whitespace characters.\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /// Find the column position at `to`, optionally starting at a given\n    /// position and column.\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /// Find the position corresponding to the given column.\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /// @internal\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* Link */ || this.stage == 3 /* Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/// Block-level parsing functions get access to this context object.\nclass BlockContext {\n    /// @internal\n    constructor(\n    /// The parser configuration used.\n    parser, \n    /// @internal\n    input, fragments, \n    /// @internal\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /// @internal\n        this.dontInject = new Set;\n        this.stoppedAt = null;\n        /// The range index that absoluteLineStart points into @internal\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            while (line.depth < this.stack.length)\n                this.finishContext();\n            for (let mark of line.markers)\n                this.addNode(mark.type, mark.from, mark.to);\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        let withoutGaps = taken, end = this.absoluteLineStart + taken;\n        for (let i = 1; i < this.ranges.length; i++) {\n            let gapFrom = this.ranges[i - 1].to, gapTo = this.ranges[i].from;\n            if (gapFrom >= this.lineStart && gapTo < end)\n                withoutGaps -= gapTo - gapFrom;\n        }\n        this.lineStart += withoutGaps;\n        this.absoluteLineStart += taken;\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /// The number of parent blocks surrounding the current block.\n    get depth() {\n        return this.stack.length;\n    }\n    /// Get the type of the parent block at the given depth. When no\n    /// depth is passed, return the type of the innermost parent.\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /// Move to the next input line. This should only be called by\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\n    /// the line directly, or leaf block parser\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    /// consume the current line (and return true).\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to)\n            this.rangeI++;\n    }\n    /// @internal\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(r.end);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /// @internal\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /// The end position of the previous line.\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /// @internal\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /// Start a composite block. Should only be called from [block\n    /// parser functions](#BlockParser.parse) that return null.\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /// @internal\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /// Add a block element. Can be called by [block\n    /// parsers](#BlockParser.parse).\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\n    /// makes sure any extra composite block markup (such as blockquote\n    /// markers) inside the block are also added to the syntax tree.\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /// @internal\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.dontInject) : tree;\n    }\n    /// @internal\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /// @internal\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dont) {\n    if (dont.has(tree.tree))\n        return tree.tree;\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node;\n        if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dont);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/// A Markdown parser configuration.\nclass MarkdownParser extends Parser {\n    /// @internal\n    constructor(\n    /// The parser's syntax [node\n    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    nodeSet, \n    /// @internal\n    blockParsers, \n    /// @internal\n    leafBlockParsers, \n    /// @internal\n    blockNames, \n    /// @internal\n    endLeafBlock, \n    /// @internal\n    skipContextMarkup, \n    /// @internal\n    inlineParsers, \n    /// @internal\n    inlineNames, \n    /// @internal\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /// @internal\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Reconfigure the parser.\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice();\n            for (let s of config.defineNodes) {\n                let { name, block, composite } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n            }\n            nodeSet = new NodeSet(nodeTypes);\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /// @internal\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /// Parse the given piece of inline text at the given offset,\n    /// returning an array of [`Element`](#Element) objects representing\n    /// the inline content.\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]]\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/// Elements are used to compose syntax nodes during parsing.\nclass Element {\n    /// @internal\n    constructor(\n    /// The node's\n    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    type, \n    /// The start of the node, as an offset from the start of the document.\n    from, \n    /// The end of the node.\n    to, \n    /// The node's child nodes @internal\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /// @internal\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /// @internal\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url)\n            return cx.append(elt(Type.URL, start, start + 1 + url[0].length));\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Open */ : 0) | (canClose ? 2 /* Close */ : 0)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n            if (title)\n                pos = cx.skipSpace(title.to);\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\nclass InlineContext {\n    /// @internal\n    constructor(\n    /// The parser that is being used.\n    parser, \n    /// The text of this inline section.\n    text, \n    /// The starting offset of the section in the document.\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /// @internal\n        this.parts = [];\n    }\n    /// Get the character code at the given (document-relative)\n    /// position.\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /// The position of the end of this inline section.\n    get end() { return this.offset + this.text.length; }\n    /// Get a substring of this inline section. Again uses\n    /// document-relative positions.\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /// @internal\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\n    /// and `close` indicate whether this delimiter is opening, closing,\n    /// or both. Returns the end of the delimiter, for convenient\n    /// returning from [parse functions](#InlineParser.parse).\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Open */ : 0) | (close ? 2 /* Close */ : 0)));\n    }\n    /// Add an inline element. Returns the end of the element.\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /// @internal\n    resolveMarkers(from) {\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (!(part instanceof InlineDelimiter && (part.side & 1 /* Open */) && part.type == close.type) ||\n                    emp && ((close.side & 1 /* Open */) || (part.side & 2 /* Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))\n                    continue;\n                open = part;\n                break;\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /// Find an opening delimiter of the given type. Returns `null` if\n    /// no delimiter is found, or an index that can be passed to\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /// Remove all inline elements and delimiters starting from the\n    /// given index (which you should get from\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    /// resolve delimiters inside of them, and return them as an array\n    /// of elements.\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /// Skip space after the given (document) position, returning either\n    /// the position of the next non-space character or the end of the\n    /// section.\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            cx.dontInject.add(cur.tree);\n            cx.addNode(cur.tree, cur.from - off);\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\n/// The default CommonMark parser.\nconst parser = new MarkdownParser(new NodeSet(nodeTypes), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\nconst Strikethrough = {\n    defineNodes: [\"Strikethrough\", \"StrikethroughMark\"],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126)\n                    return -1;\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, true, true);\n            },\n            after: \"Emphasis\"\n        }]\n};\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        \"TableHeader\",\n        \"TableRow\",\n        \"TableCell\",\n        \"TableDelimiter\"\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true },\n        \"TaskMarker\"\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\n/// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList) and [`Strikethrough`](#Strikethrough).\nconst GFM = [Table, TaskList, Strikethrough];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\nconst Superscript = {\n    defineNodes: [\"Superscript\", \"SuperscriptMark\"],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\nconst Subscript = {\n    defineNodes: [\"Subscript\", \"SubscriptMark\"],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\nconst Emoji = {\n    defineNodes: [\"Emoji\"],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n","import { EditorSelection, Prec } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, Language, LanguageDescription, ParseContext, syntaxTree, LanguageSupport } from '@codemirror/language';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html } from '@codemirror/lang-html';\nimport { styleTags, tags } from '@codemirror/highlight';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ block: { open: \"<!--\", close: \"-->\" } });\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/styleTags({\n            \"Blockquote/...\": tags.quote,\n            HorizontalRule: tags.contentSeparator,\n            \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n            \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n            \"ATXHeading3/...\": tags.heading3,\n            \"ATXHeading4/...\": tags.heading4,\n            \"ATXHeading5/...\": tags.heading5,\n            \"ATXHeading6/...\": tags.heading6,\n            \"Comment CommentBlock\": tags.comment,\n            Escape: tags.escape,\n            Entity: tags.character,\n            \"Emphasis/...\": tags.emphasis,\n            \"StrongEmphasis/...\": tags.strong,\n            \"Link/... Image/...\": tags.link,\n            \"OrderedList/... BulletList/...\": tags.list,\n            \"BlockQuote/...\": tags.quote,\n            \"InlineCode CodeText\": tags.monospace,\n            URL: tags.url,\n            \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n            \"CodeInfo LinkLabel\": tags.labelName,\n            LinkTitle: tags.string,\n            Paragraph: tags.content\n        }),\n        /*@__PURE__*/foldNodeProp.add(type => {\n            if (!type.is(\"Block\") || type.is(\"Document\"))\n                return undefined;\n            return (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction mkLang(parser) {\n    return new Language(data, parser, parser.nodeSet.types.find(t => t.name == \"Document\"));\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji, {\n        props: [\n            /*@__PURE__*/styleTags({\n                \"TableDelimiter SubscriptMark SuperscriptMark StrikethroughMark\": tags.processingInstruction,\n                \"TableHeader/...\": tags.heading,\n                \"Strikethrough/...\": tags.strikethrough,\n                TaskMarker: tags.atom,\n                Task: tags.list,\n                Emoji: tags.character,\n                \"Subscript Superscript\": /*@__PURE__*/tags.special(tags.content),\n                TableCell: tags.content\n            })\n        ]\n    }]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        let found = info && LanguageDescription.matchLanguageName(languages, info, true);\n        if (!found)\n            return defaultLanguage ? defaultLanguage.parser : null;\n        if (found.support)\n            return found.support.language.parser;\n        return ParseContext.getSkippingParser(found.load());\n    };\n}\n\nfunction nodeStart(node, doc) {\n    return doc.sliceString(node.from, node.from + 50);\n}\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(trailing = true) {\n        let result = this.spaceBefore;\n        if (this.node.name == \"Blockquote\")\n            result += \">\";\n        else\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n        return result + (trailing ? this.spaceAfter : \"\");\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, line, doc) {\n    let nodes = [];\n    for (let cur = node; cur && cur.name != \"Document\"; cur = cur.parent) {\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\")\n            nodes.push(cur);\n    }\n    let context = [], pos = 0;\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match, start = pos;\n        if (node.name == \"Blockquote\" && (match = /^[ \\t]*>( ?)/.exec(line.slice(pos)))) {\n            pos += match[0].length;\n            context.push(new Context(node, start, pos, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^([ \\t]*)\\d+([.)])([ \\t]*)/.exec(nodeStart(node, doc)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            pos += len;\n            context.push(new Context(node.parent, start, pos, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^([ \\t]*)([-+*])([ \\t]+)/.exec(nodeStart(node, doc)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            pos += len;\n            context.push(new Context(node.parent, start, pos, match[1], after, match[2], node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), line.text, doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            // First list item or blank line before: delete a level of markup\n            if (inner.node.firstChild.to >= pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move this line down\n                let insert = \"\";\n                for (let i = 0, e = context.length - 2; i <= e; i++)\n                    insert += context[i].blank(i < e);\n                insert += state.lineBreak;\n                return { range: EditorSelection.cursor(pos + insert.length), changes: { from: line.from, insert } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let insert = state.lineBreak;\n        let continued = inner.item && inner.item.from < line.from;\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++)\n                insert += i == e && !continued ? context[i].marker(doc, 1) : context[i].blank();\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        changes.push({ from, to: pos, insert });\n        return { range: EditorSelection.cursor(from + insert.length), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), line.text, doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to)))\n                        return { range, changes: { from: start, to: line.from + inner.to, insert: inner.blank() } };\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlNoMatch.support], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages || [], defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    return new LanguageSupport(mkLang(parser.configure(extensions)), support);\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n"]}