{"version":3,"sources":["src/components/codeBlock/codeBlock.css?tag=stencila-code-block&mode=default&encapsulation=scoped","src/components/codeBlock/codeBlock.material.css?tag=stencila-code-block&mode=material&encapsulation=scoped","src/components/codeBlock/codeBlock.tsx"],"names":["defaultCodeBlockCss","codeBlockMaterialCss","CodeBlockComponent","[object Object]","hostRef","this","autofocus","lineWrapping","lineNumbers","foldGutter","readOnly","keymap","handleLanguageChange","e","programmingLanguage","undefined","lookupFormat","name","detail","executableLanguages","languages","editorRef","text","language","_a","getContents","codeBlock","Error","getRef","h","Host","class","editorContainer","activeLanguage","onStencila-language-change","ref","el","slots","errors","label","caption","outputs"],"mappings":"qHAAA,MAAMA,EAAsB,m+DCA5B,MAAMC,EAAuB,kgEC4BhBC,EAAkB,MAR/BC,YAAAC,aA6BiBC,KAAAC,UAAY,MAMpBD,KAAAE,aAAe,MAMfF,KAAAG,YAAc,KAMdH,KAAAI,WAAa,KAYbJ,KAAAK,SAAW,MAmBHL,KAAAM,OAAmB,GAY1BN,KAAAO,qBAAwBC,IAC9B,GACER,KAAKS,sBAAwBC,WAC7BC,EAAaX,KAAKS,qBAAqBG,OAASJ,EAAEK,OAAOD,KACzD,CACAZ,KAAKS,oBAAsBD,EAAEK,OAAOD,OA3BxCd,+BAA8Be,OAC5BA,IAEAb,KAAKc,oBAAsBD,EAAOE,UAgC7BjB,0BACL,GAAIE,KAAKgB,UAAW,CAClB,MAAMC,KAAEA,EAAIC,SAAEA,UAAmBC,EAAAnB,KAAKgB,aAAS,MAAAG,SAAA,OAAA,EAAAA,EAAEC,eACjD,OAAOC,EAAU,CAAEJ,KAAAA,EAAMR,oBAAqBS,IAGhD,MAAM,IAAII,MAAM,oCAOXxB,8BACL,GAAIE,KAAKgB,UAAW,CAClB,MAAMC,KAAEA,UAAeE,EAAAnB,KAAKgB,aAAS,MAAAG,SAAA,OAAA,EAAAA,EAAEC,eACvC,OAAOH,EAGT,MAAM,IAAIK,MAAM,oCAQXxB,qBACL,OAAOqB,EAAAnB,KAAKgB,aAAS,MAAAG,SAAA,OAAA,EAAAA,EAAEI,SAGlBzB,SACL,OACE0B,EAACC,EAAI,KACHD,EAAA,SAAA,KACEA,EAAA,MAAA,KACEA,EAAA,MAAA,CACEE,MAAO,CACLC,gBAAiB,OAGnBH,EAAA,kBAAA,CACEI,eAAgB5B,KAAKS,oBACrBK,oBAAqBd,KAAKc,oBAC1Bb,UAAWD,KAAKC,UAChBK,OAAQN,KAAKM,OACbD,SAAUL,KAAKK,SAAQwB,6BACK7B,KAAKO,qBACjCH,WAAYJ,KAAKI,WACjBD,YAAaH,KAAKG,YAClBD,aAAcF,KAAKE,aACnB4B,IAAMC,IACJ/B,KAAKgB,UAAYe,IAGnBP,EAAA,OAAA,CAAMZ,KAAMf,EAAmBmC,MAAMf,OACrCO,EAAA,OAAA,CAAMZ,KAAMf,EAAmBmC,MAAMC,YAK3CT,EAAA,OAAA,CAAMZ,KAAMf,EAAmBmC,MAAME,QAErCV,EAAA,OAAA,CAAMZ,KAAMf,EAAmBmC,MAAMG,cA7JrBtC,EAAAmC,MAAQ,CAC9Bf,KAAM,OACNmB,QAAS,UACTH,OAAQ,SACRE,QAAS,UACTD,MAAO","sourcesContent":["@import '~@stencila/style-stencila/dist/molecules/codeBlock.css';\n","@import '~@stencila/style-stencila/dist/molecules/codeBlock.css';\n","import { EditorView } from '@codemirror/view'\nimport { Component, h, Host, Listen, Method, Prop } from '@stencil/core'\nimport { CodeBlock, codeBlock } from '@stencila/schema'\nimport {\n  CodeComponent,\n  DiscoverExecutableLanguagesEvent,\n} from '../code/codeTypes'\nimport { EditorUpdateHandlerCb } from '../editor/customizations/onUpdateHandlerExtension'\nimport { Keymap } from '../editor/editor'\nimport {\n  FileFormat,\n  FileFormatMap,\n  lookupFormat,\n} from '../editor/languageUtils'\n\n/**\n * @slot text - The source code of the `CodeChunk`. Corresponds to the `text` field in the Stencila `CodeChunk` Schema.\n * @slot label - `label` element label of the `CodeChunk`. Corresponds to the `label` field in the Stencila `CodeChunk` Schema.\n * @slot caption - `figcaption` content of the `CodeChunk`. Corresponds to the `caption` field in the Stencila `CodeChunk` Schema.\n */\n@Component({\n  tag: 'stencila-code-block',\n  styleUrls: {\n    default: 'codeBlock.css',\n    material: 'codeBlock.material.css',\n  },\n  scoped: true,\n})\nexport class CodeBlockComponent implements CodeComponent<CodeBlock> {\n  private static readonly slots = {\n    text: 'text',\n    outputs: 'outputs',\n    errors: 'errors',\n    caption: 'caption',\n    label: 'label',\n  }\n\n  public editorRef: HTMLStencilaEditorElement | undefined\n\n  /**\n   * Source code contents of the CodeChunk.\n   * Corresponds to the `text` property of the CodeBlock schema.\n   */\n  @Prop()\n  public text?: string\n\n  /**\n   * Autofocus the editor on page load\n   */\n  @Prop() public autofocus = false\n\n  /**\n   * Control line wrapping of text inside the editor\n   */\n  @Prop()\n  public lineWrapping = false\n\n  /**\n   * Determines the visibility of line numbers\n   */\n  @Prop()\n  public lineNumbers = true\n\n  /**\n   * Enables ability to fold sections of code if the syntax package supports it\n   */\n  @Prop()\n  public foldGutter = true\n\n  /**\n   * Programming language of the CodeChunk\n   */\n  @Prop({ mutable: true })\n  public programmingLanguage: string | undefined\n\n  /**\n   * Disallow editing of the editor contents when set to `true`\n   */\n  @Prop()\n  public readOnly = false\n\n  /**\n   * List of programming languages that can be executed in the current context\n   */\n  @Prop()\n  public executableLanguages?: FileFormatMap\n\n  @Listen('stencila-discover-executable-languages', { target: 'window' })\n  onDiscoverExecutableLanguages({\n    detail,\n  }: DiscoverExecutableLanguagesEvent): void {\n    this.executableLanguages = detail.languages\n  }\n\n  /**\n   * Custom keyboard shortcuts to pass along to CodeMirror\n   * @see https://codemirror.net/6/docs/ref/#keymap\n   */\n  @Prop() public keymap: Keymap[] = []\n\n  /**\n   * Callback function to invoke whenever the editor contents are updated.\n   */\n  @Prop()\n  public contentChangeHandler?: EditorUpdateHandlerCb\n\n  /**\n   * Listen for the `stencila-language-change` event emitted by the language dropdown\n   * provided by the child Editor component, and update the active language if necessary.\n   */\n  private handleLanguageChange = (e: CustomEvent<FileFormat>) => {\n    if (\n      this.programmingLanguage === undefined ||\n      lookupFormat(this.programmingLanguage).name !== e.detail.name\n    ) {\n      this.programmingLanguage = e.detail.name\n    }\n  }\n\n  /**\n   * Returns the `CodeChunk` node with the updated `text` content from the editor.\n   */\n  @Method()\n  public async getContents(): Promise<CodeBlock> {\n    if (this.editorRef) {\n      const { text, language } = await this.editorRef?.getContents()\n      return codeBlock({ text, programmingLanguage: language })\n    }\n\n    throw new Error('Could not get CodeChunk contents')\n  }\n\n  /**\n   * Returns the text contents from the editor\n   */\n  @Method()\n  public async getTextContents(): Promise<string> {\n    if (this.editorRef) {\n      const { text } = await this.editorRef?.getContents()\n      return text\n    }\n\n    throw new Error('Could not get CodeBlock contents')\n  }\n\n  /**\n   * Retrieve a reference to the internal CodeMirror editor.\n   * Allows for maintaining state from applications making use of this component.\n   */\n  @Method()\n  public async getRef(): Promise<EditorView | undefined> {\n    return this.editorRef?.getRef()\n  }\n\n  public render(): HTMLElement {\n    return (\n      <Host>\n        <figure>\n          <div>\n            <div\n              class={{\n                editorContainer: true,\n              }}\n            >\n              <stencila-editor\n                activeLanguage={this.programmingLanguage}\n                executableLanguages={this.executableLanguages}\n                autofocus={this.autofocus}\n                keymap={this.keymap}\n                readOnly={this.readOnly}\n                onStencila-language-change={this.handleLanguageChange}\n                foldGutter={this.foldGutter}\n                lineNumbers={this.lineNumbers}\n                lineWrapping={this.lineWrapping}\n                ref={(el) => {\n                  this.editorRef = el\n                }}\n              >\n                <slot name={CodeBlockComponent.slots.text} />\n                <slot name={CodeBlockComponent.slots.errors} />\n              </stencila-editor>\n            </div>\n          </div>\n\n          <slot name={CodeBlockComponent.slots.label} />\n\n          <slot name={CodeBlockComponent.slots.caption} />\n        </figure>\n      </Host>\n    )\n  }\n}\n"]}