{"version":3,"sources":["node_modules/@codemirror/stream-parser/dist/index.js"],"names":["countCol","string","end","tabSize","startIndex","startValue","search","length","n","i","charCodeAt","StringStream","indentUnit","this","pos","start","lastColumnPos","lastColumnValue","prototype","eol","sol","peek","charAt","undefined","next","eat","match","ch","ok","RegExp","test","eatWhile","eatSpace","skipToEnd","skipTo","found","indexOf","backUp","column","indentation","pattern","consume","caseInsensitive","cased","str","toLowerCase","substr","slice","index","current","exports","fullParser","spec","token","blankLine","startState","copyState","defaultCopyState","indent","languageData","tokenTable","noTokens","state","newState","prop","val","Array","StreamLanguage","_super","__extends","parser","_this","data","defineLanguageFacet","p","self","impl","class_1","createParse","input","fragments","ranges","Parse","Parser","call","docID","indentService","of","cx","getIndent","streamParser","stateAfter","NodeProp","perNode","TokenTable","defaultTokenTable","define","tree","syntaxTree","at","resolve","type","topNode","parent","findState","from","statePos","unit","line","doc","lineAt","Math","min","to","stream","text","readToken","exec","Object","defineProperty","Language","lang","off","startPos","before","children","child","positions","Tree","cutTree","inside","inner","concat","findStartInFragments","editorState","_i","fragments_1","f","openStart","openEnd","offset","getIndentUnit","empty","stoppedAt","chunks","chunkPos","chunk","chunkReused","rangeIndex","context","ParseContext","get","_a","parsedPos","chunkStart","push","viewport","skipUntilInView","advance","parseEnd","parseLine","finishChunk","finish","stopAt","lineAfter","lineChunks","nextLine","rangeEnd","rangeStart","after","skipGapsTo","side","offPos","emitToken","id","size","len0","build","buffer","nodeSet","topID","maxBufferLength","reused","balance","result","Error","create","typeArray","NodeType","none","NodeSet","warned","defaultTable","_b","legacyName","name","createTokenType","extra","table","assign","tag","warnForPart","part","msg","console","warn","tagStr","split","value","tags","replace","props","styleTags","languageDataProp","add"],"mappings":"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","sourcesContent":["import { NodeType, NodeSet, Parser, NodeProp, Tree } from '@lezer/common';\nimport { tags, styleTags } from '@codemirror/highlight';\nimport { Language, defineLanguageFacet, indentService, syntaxTree, ParseContext, getIndentUnit, languageDataProp } from '@codemirror/language';\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n    if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1)\n            end = string.length;\n    }\n    let n = startValue;\n    for (let i = startIndex; i < end; i++) {\n        if (string.charCodeAt(i) == 9)\n            n += tabSize - (n % tabSize);\n        else\n            n++;\n    }\n    return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/\nclass StringStream {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The line.\n    */\n    string, tabSize, \n    /**\n    The current indent unit size.\n    */\n    indentUnit) {\n        this.string = string;\n        this.tabSize = tabSize;\n        this.indentUnit = indentUnit;\n        /**\n        The current position on the line.\n        */\n        this.pos = 0;\n        /**\n        The start position of the current token.\n        */\n        this.start = 0;\n        this.lastColumnPos = 0;\n        this.lastColumnValue = 0;\n    }\n    /**\n    True if we are at the end of the line.\n    */\n    eol() { return this.pos >= this.string.length; }\n    /**\n    True if we are at the start of the line.\n    */\n    sol() { return this.pos == 0; }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */\n    peek() { return this.string.charAt(this.pos) || undefined; }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */\n    next() {\n        if (this.pos < this.string.length)\n            return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */\n    eat(match) {\n        let ch = this.string.charAt(this.pos);\n        let ok;\n        if (typeof match == \"string\")\n            ok = ch == match;\n        else\n            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */\n    eatWhile(match) {\n        let start = this.pos;\n        while (this.eat(match)) { }\n        return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */\n    eatSpace() {\n        let start = this.pos;\n        while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n            ++this.pos;\n        return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */\n    skipToEnd() { this.pos = this.string.length; }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */\n    skipTo(ch) {\n        let found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    }\n    /**\n    Move back `n` characters.\n    */\n    backUp(n) { this.pos -= n; }\n    /**\n    Get the column position at `this.pos`.\n    */\n    column() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */\n    indentation() {\n        return countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */\n    match(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;\n            let substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false)\n                    this.pos += pattern.length;\n                return true;\n            }\n            else\n                return null;\n        }\n        else {\n            let match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0)\n                return null;\n            if (match && consume !== false)\n                this.pos += match[0].length;\n            return match;\n        }\n    }\n    /**\n    Get the current token.\n    */\n    current() { return this.string.slice(this.start, this.pos); }\n}\n\nfunction fullParser(spec) {\n    return {\n        token: spec.token,\n        blankLine: spec.blankLine || (() => { }),\n        startState: spec.startState || (() => true),\n        copyState: spec.copyState || defaultCopyState,\n        indent: spec.indent || (() => null),\n        languageData: spec.languageData || {},\n        tokenTable: spec.tokenTable || noTokens\n    };\n}\nfunction defaultCopyState(state) {\n    if (typeof state != \"object\")\n        return state;\n    let newState = {};\n    for (let prop in state) {\n        let val = state[prop];\n        newState[prop] = (val instanceof Array ? val.slice() : val);\n    }\n    return newState;\n}\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a streaming\nparser.\n*/\nclass StreamLanguage extends Language {\n    constructor(parser) {\n        let data = defineLanguageFacet(parser.languageData);\n        let p = fullParser(parser), self;\n        let impl = new class extends Parser {\n            createParse(input, fragments, ranges) {\n                return new Parse(self, input, fragments, ranges);\n            }\n        };\n        super(data, impl, docID(data), [indentService.of((cx, pos) => this.getIndent(cx, pos))]);\n        self = this;\n        this.streamParser = p;\n        this.stateAfter = new NodeProp({ perNode: true });\n        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n    }\n    static define(spec) { return new StreamLanguage(spec); }\n    getIndent(cx, pos) {\n        let tree = syntaxTree(cx.state), at = tree.resolve(pos);\n        while (at && at.type != this.topNode)\n            at = at.parent;\n        if (!at)\n            return null;\n        let start = findState(this, tree, 0, at.from, pos), statePos, state;\n        if (start) {\n            state = start.state;\n            statePos = start.pos + 1;\n        }\n        else {\n            state = this.streamParser.startState(cx.unit);\n            statePos = 0;\n        }\n        if (pos - statePos > 10000 /* MaxIndentScanDist */)\n            return null;\n        while (statePos < pos) {\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);\n            if (line.length) {\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit);\n                while (stream.pos < end - line.from)\n                    readToken(this.streamParser.token, stream, state);\n            }\n            else {\n                this.streamParser.blankLine(state, cx.unit);\n            }\n            if (end == pos)\n                break;\n            statePos = line.to + 1;\n        }\n        let { text } = cx.lineAt(pos);\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(text)[1], cx);\n    }\n    get allowsNesting() { return false; }\n}\nfunction findState(lang, tree, off, startPos, before) {\n    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n    if (state)\n        return { state: lang.streamParser.copyState(state), pos: off + tree.length };\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let child = tree.children[i], pos = off + tree.positions[i];\n        let found = child instanceof Tree && pos < before && findState(lang, child, pos, startPos, before);\n        if (found)\n            return found;\n    }\n    return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n    if (inside && from <= 0 && to >= tree.length)\n        return tree;\n    if (!inside && tree.type == lang.topNode)\n        inside = true;\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let pos = tree.positions[i], child = tree.children[i], inner;\n        if (pos < to && child instanceof Tree) {\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))\n                break;\n            return !inside ? inner\n                : new Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n        }\n    }\n    return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n    for (let f of fragments) {\n        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);\n        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;\n        if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))\n            return { state: found.state, tree };\n    }\n    return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: Tree.empty };\n}\nclass Parse {\n    constructor(lang, input, fragments, ranges) {\n        this.lang = lang;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.stoppedAt = null;\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.rangeIndex = 0;\n        this.to = ranges[ranges.length - 1].to;\n        let context = ParseContext.get(), from = ranges[0].from;\n        let { state, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);\n        this.state = state;\n        this.parsedPos = this.chunkStart = from + tree.length;\n        for (let i = 0; i < tree.children.length; i++) {\n            this.chunks.push(tree.children[i]);\n            this.chunkPos.push(tree.positions[i]);\n        }\n        if (context && this.parsedPos < context.viewport.from - 100000 /* MaxDistanceBeforeViewport */) {\n            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n            context.skipUntilInView(this.parsedPos, context.viewport.from);\n            this.parsedPos = context.viewport.from;\n        }\n    }\n    advance() {\n        let context = ParseContext.get();\n        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n        let end = Math.min(parseEnd, this.chunkStart + 2048 /* ChunkSize */);\n        if (context)\n            end = Math.min(end, context.viewport.to);\n        while (this.parsedPos < end)\n            this.parseLine(context);\n        if (this.chunkStart < this.parsedPos)\n            this.finishChunk();\n        if (this.parsedPos >= parseEnd)\n            return this.finish();\n        if (context && this.parsedPos >= context.viewport.to) {\n            context.skipUntilInView(this.parsedPos, parseEnd);\n            return this.finish();\n        }\n        return null;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n    }\n    lineAfter(pos) {\n        let chunk = this.input.chunk(pos);\n        if (!this.input.lineChunks) {\n            let eol = chunk.indexOf(\"\\n\");\n            if (eol > -1)\n                chunk = chunk.slice(0, eol);\n        }\n        else if (chunk == \"\\n\") {\n            chunk = \"\";\n        }\n        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n    nextLine() {\n        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;\n        for (let index = this.rangeIndex;;) {\n            let rangeEnd = this.ranges[index].to;\n            if (rangeEnd >= end)\n                break;\n            line = line.slice(0, rangeEnd - (end - line.length));\n            index++;\n            if (index == this.ranges.length)\n                break;\n            let rangeStart = this.ranges[index].from;\n            let after = this.lineAfter(rangeStart);\n            line += after;\n            end = rangeStart + after.length;\n        }\n        return { line, end };\n    }\n    skipGapsTo(pos, offset, side) {\n        for (;;) {\n            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;\n            if (side > 0 ? end > offPos : end >= offPos)\n                break;\n            let start = this.ranges[++this.rangeIndex].from;\n            offset += start - end;\n        }\n        return offset;\n    }\n    emitToken(id, from, to, size, offset) {\n        if (this.ranges.length > 1) {\n            offset = this.skipGapsTo(from, offset, 1);\n            from += offset;\n            let len0 = this.chunk.length;\n            offset = this.skipGapsTo(to, offset, -1);\n            to += offset;\n            size += this.chunk.length - len0;\n        }\n        this.chunk.push(id, from, to, size);\n        return offset;\n    }\n    parseLine(context) {\n        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;\n        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n        if (stream.eol()) {\n            streamParser.blankLine(this.state, stream.indentUnit);\n        }\n        else {\n            while (!stream.eol()) {\n                let token = readToken(streamParser.token, stream, this.state);\n                if (token)\n                    offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n                if (stream.start > 10000 /* MaxLineLength */)\n                    break;\n            }\n        }\n        this.parsedPos = end;\n        if (this.parsedPos < this.to)\n            this.parsedPos++;\n    }\n    finishChunk() {\n        let tree = Tree.build({\n            buffer: this.chunk,\n            start: this.chunkStart,\n            length: this.parsedPos - this.chunkStart,\n            nodeSet,\n            topID: 0,\n            maxBufferLength: 2048 /* ChunkSize */,\n            reused: this.chunkReused\n        });\n        tree = new Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);\n        this.chunks.push(tree);\n        this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.chunkStart = this.parsedPos;\n    }\n    finish() {\n        return new Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n}\nfunction readToken(token, stream, state) {\n    stream.start = stream.pos;\n    for (let i = 0; i < 10; i++) {\n        let result = token(stream, state);\n        if (stream.pos > stream.start)\n            return result;\n    }\n    throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = /*@__PURE__*/Object.create(null);\nconst typeArray = [NodeType.none];\nconst nodeSet = /*@__PURE__*/new NodeSet(typeArray);\nconst warned = [];\nconst defaultTable = /*@__PURE__*/Object.create(null);\nfor (let [legacyName, name] of [\n    [\"variable\", \"variableName\"],\n    [\"variable-2\", \"variableName.special\"],\n    [\"string-2\", \"string.special\"],\n    [\"def\", \"variableName.definition\"],\n    [\"tag\", \"typeName\"],\n    [\"attribute\", \"propertyName\"],\n    [\"type\", \"typeName\"],\n    [\"builtin\", \"variableName.standard\"],\n    [\"qualifier\", \"modifier\"],\n    [\"error\", \"invalid\"],\n    [\"header\", \"heading\"],\n    [\"property\", \"propertyName\"]\n])\n    defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);\nclass TokenTable {\n    constructor(extra) {\n        this.extra = extra;\n        this.table = Object.assign(Object.create(null), defaultTable);\n    }\n    resolve(tag) {\n        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n    }\n}\nconst defaultTokenTable = /*@__PURE__*/new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n    if (warned.indexOf(part) > -1)\n        return;\n    warned.push(part);\n    console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n    let tag = null;\n    for (let part of tagStr.split(\".\")) {\n        let value = (extra[part] || tags[part]);\n        if (!value) {\n            warnForPart(part, `Unknown highlighting tag ${part}`);\n        }\n        else if (typeof value == \"function\") {\n            if (!tag)\n                warnForPart(part, `Modifier ${part} used at start of tag`);\n            else\n                tag = value(tag);\n        }\n        else {\n            if (tag)\n                warnForPart(part, `Tag ${part} used as modifier`);\n            else\n                tag = value;\n        }\n    }\n    if (!tag)\n        return 0;\n    let name = tagStr.replace(/ /g, \"_\"), type = NodeType.define({\n        id: typeArray.length,\n        name,\n        props: [styleTags({ [name]: tag })]\n    });\n    typeArray.push(type);\n    return type.id;\n}\nfunction docID(data) {\n    let type = NodeType.define({ id: typeArray.length, name: \"Document\", props: [languageDataProp.add(() => data)] });\n    typeArray.push(type);\n    return type;\n}\n\nexport { StreamLanguage, StringStream };\n"]}