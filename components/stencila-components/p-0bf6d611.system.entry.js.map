{"version":3,"sources":["node_modules/animate-presence/dist/collection/components/animate-presence/animate-presence.js"],"names":["hold","el","cb","__awaiter","_this","dataset","then","r","finished","_c","sent","AnimatePresence","exports","class_1","hostRef","this","__presenceKey","concat","ids","descendants","getClosestParent","_a","base","element","parentElement","getRootNode","host","closest","tagName","willExit","didExit","willEnter","didEnter","handleMutation","bind","prototype","observeChanged","observe","addMO","mo","childList","attributes","attributeFilter","removeMO","componentWillLoad","injectGlobalStyle","ancestor","_b","Array","from","children","map","i","setCustomProperties","style","setProperty","enter","componentDidLoad","registerChild","componentDidUnload","unregisterChild","enterNode","exit","event","CustomEvent","bubbles","detail","dispatchEvent","removeProperty","presence","afterSelf","initial","enterChildren","exitNode","method","exitChildren","remove","Promise","resolve","handleEnter","node","_record","isHTMLElement","hasData","handleExit","record","previousSibling","insertAdjacentElement","target","prepend","records","_i","reverse","length","addedNodes","removedNodes","window","MutationObserver","disconnect","undefined","key","__spreadArray","filter","animatePresenceExitCompleteHandler","stopPropagation","all","animatePresenceExitComplete","emit","render","h","Host","display"],"mappings":"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","sourcesContent":["import { h, Host } from \"@stencil/core\";\r\nimport { setCustomProperties, isHTMLElement, hasData, presence, closest, enterChildren, exitChildren, injectGlobalStyle, } from '../../utils';\r\nconst hold = (el) => async (cb) => {\r\n    el.dataset.hold = '';\r\n    await cb(el).then((r) => {\r\n        if (r && 'finished' in r) {\r\n            return r.finished;\r\n        }\r\n        return;\r\n    });\r\n    delete el.dataset.hold;\r\n};\r\nexport class AnimatePresence {\r\n    constructor() {\r\n        /** @internal */\r\n        this.__presenceKey = `animate-presence-${ids++}`;\r\n        /** @internal */\r\n        this.descendants = [];\r\n        this.getClosestParent = () => {\r\n            var _a;\r\n            const base = (_a = this.element.parentElement, (_a !== null && _a !== void 0 ? _a : this.element.getRootNode().host));\r\n            return closest(this.element.tagName, base);\r\n        };\r\n        this.willExit = false;\r\n        this.didExit = false;\r\n        this.willEnter = false;\r\n        this.didEnter = false;\r\n        this.handleMutation = this.handleMutation.bind(this);\r\n    }\r\n    observeChanged() {\r\n        if (this.observe) {\r\n            this.addMO();\r\n            this.mo.observe(this.element, {\r\n                childList: true,\r\n                attributes: true,\r\n                attributeFilter: ['data-key'],\r\n            });\r\n        }\r\n        else {\r\n            this.removeMO();\r\n        }\r\n    }\r\n    async componentWillLoad() {\r\n        var _a, _b;\r\n        injectGlobalStyle();\r\n        this.ancestor = this.getClosestParent();\r\n        if (typeof this.observe === 'undefined') {\r\n            this.observe = (_b = (_a = this.ancestor) === null || _a === void 0 ? void 0 : _a.observe, (_b !== null && _b !== void 0 ? _b : true));\r\n        }\r\n        Array.from(this.element.children).map((el, i) => {\r\n            setCustomProperties(el, { i });\r\n            el.style.setProperty('animation-play-state', 'paused');\r\n            el.dataset.enter = '';\r\n        });\r\n    }\r\n    async componentDidLoad() {\r\n        var _a;\r\n        this.observeChanged();\r\n        (_a = this.ancestor) === null || _a === void 0 ? void 0 : _a.registerChild(this.element);\r\n        if (!this.ancestor) {\r\n            this.enter();\r\n        }\r\n    }\r\n    async componentDidUnload() {\r\n        var _a;\r\n        this.removeMO();\r\n        (_a = this.ancestor) === null || _a === void 0 ? void 0 : _a.unregisterChild(this.__presenceKey);\r\n        this.descendants = [];\r\n    }\r\n    async enterNode(el, i = 0) {\r\n        delete el.dataset.exit;\r\n        const event = new CustomEvent('animatePresenceEnter', {\r\n            bubbles: true,\r\n            detail: {\r\n                i,\r\n                hold: hold(el),\r\n            },\r\n        });\r\n        el.dispatchEvent(event);\r\n        el.style.removeProperty('animation-play-state');\r\n        el.dataset.enter = '';\r\n        setCustomProperties(el, { i });\r\n        await presence(el, {\r\n            afterSelf: async () => {\r\n                delete el.dataset.initial;\r\n                delete el.dataset.enter;\r\n                el.style.removeProperty('--i');\r\n            },\r\n        });\r\n        return enterChildren(el);\r\n    }\r\n    async exitNode(el, method = 'remove', i = 0) {\r\n        await exitChildren(el);\r\n        delete el.dataset.willExit;\r\n        setCustomProperties(el, { i });\r\n        const event = new CustomEvent('animatePresenceExit', {\r\n            bubbles: true,\r\n            detail: {\r\n                i,\r\n                hold: hold(el),\r\n            },\r\n        });\r\n        el.dispatchEvent(event);\r\n        el.dataset.exit = '';\r\n        await presence(el, {\r\n            afterSelf: () => {\r\n                if (method === 'remove') {\r\n                    el.remove();\r\n                }\r\n                else if (method === 'hide') {\r\n                    el.style.setProperty('visibility', 'hidden');\r\n                }\r\n            },\r\n        });\r\n        return Promise.resolve();\r\n    }\r\n    async handleEnter(node, _record, i) {\r\n        if (!isHTMLElement(node))\r\n            return;\r\n        if (hasData(node, 'exit'))\r\n            return;\r\n        if (hasData(node, 'willExit')) {\r\n            return this.exitNode(node, 'remove', i);\r\n        }\r\n        else {\r\n            return this.enterNode(node, i);\r\n        }\r\n    }\r\n    async handleExit(node, record, i) {\r\n        if (!isHTMLElement(node))\r\n            return;\r\n        if (hasData(node, 'exit') || hasData(node, 'willExit')) {\r\n            return;\r\n        }\r\n        node.dataset.willExit = '';\r\n        setCustomProperties(node, { i });\r\n        if (isHTMLElement(record.previousSibling)) {\r\n            record.previousSibling.insertAdjacentElement('afterend', node);\r\n        }\r\n        else if (isHTMLElement(record.target)) {\r\n            record.target.prepend(node);\r\n        }\r\n    }\r\n    handleMutation(records) {\r\n        let i = 0;\r\n        for (const record of records.reverse()) {\r\n            if (record.addedNodes.length === 1) {\r\n                this.handleEnter(record.addedNodes[0], record, records.length - 1 - i);\r\n            }\r\n            if (record.removedNodes.length === 1) {\r\n                this.handleExit(record.removedNodes[0], record, i);\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    addMO() {\r\n        if (!this.mo) {\r\n            if ('MutationObserver' in window) {\r\n                this.mo = new MutationObserver(this.handleMutation);\r\n                this.observeChanged();\r\n            }\r\n        }\r\n    }\r\n    removeMO() {\r\n        if (this.mo) {\r\n            this.mo.disconnect();\r\n            this.mo = undefined;\r\n        }\r\n    }\r\n    /** @internal Registers a child element across shadow boundaries */\r\n    async registerChild(el) {\r\n        const key = el.__presenceKey;\r\n        // Remove existing elements with same key to handle HMR\r\n        this.descendants = [\r\n            ...this.descendants.filter(element => element.__presenceKey !== key),\r\n            el,\r\n        ];\r\n        return;\r\n    }\r\n    /** @internal */\r\n    async unregisterChild(key) {\r\n        this.descendants = this.descendants.filter(el => el.__presenceKey !== key);\r\n        return;\r\n    }\r\n    animatePresenceExitCompleteHandler(event) {\r\n        event.stopPropagation();\r\n    }\r\n    /**\r\n     * Programmatically triggers an exit.\r\n     *\r\n     * Nested `<animate-presence>` children will be animated out from the bottom up, meaning that children elements trigger a parent's exit after their own exit finishes.\r\n     */\r\n    async exit() {\r\n        if (this.didExit || this.willExit)\r\n            return;\r\n        this.willExit = true;\r\n        await Promise.all(Array.from(this.element.children)\r\n            .reverse()\r\n            .map((el, i) => this.exitNode(el, 'hide', i)));\r\n        this.didExit = true;\r\n        this.willExit = false;\r\n        this.animatePresenceExitComplete.emit();\r\n        return Promise.resolve();\r\n    }\r\n    /**\r\n     * Programmatically triggers an entrance.\r\n     *\r\n     * Nested `<animate-presence>` children will be animated in from the top down, meaning that parent elements trigger a child's entrance after their own entrance finishes.\r\n     */\r\n    async enter() {\r\n        this.didExit = false;\r\n        this.willExit = false;\r\n        if (this.didEnter || this.willEnter)\r\n            return;\r\n        this.willEnter = true;\r\n        await Promise.all(Array.from(this.element.children).map((el, i) => this.enterNode(el, i)));\r\n        await enterChildren(this.element);\r\n        this.didEnter = true;\r\n        this.willEnter = false;\r\n        return Promise.resolve();\r\n    }\r\n    render() {\r\n        return (h(Host, { style: { display: 'contents' } },\r\n            h(\"slot\", null)));\r\n    }\r\n    static get is() { return \"animate-presence\"; }\r\n    static get encapsulation() { return \"shadow\"; }\r\n    static get properties() { return {\r\n        \"__presenceKey\": {\r\n            \"type\": \"string\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"string\",\r\n                \"resolved\": \"string\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [{\r\n                        \"text\": undefined,\r\n                        \"name\": \"internal\"\r\n                    }],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"__presence-key\",\r\n            \"reflect\": false,\r\n            \"defaultValue\": \"`animate-presence-${ids++}`\"\r\n        },\r\n        \"descendants\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"HTMLAnimatePresenceElement[]\",\r\n                \"resolved\": \"HTMLAnimatePresenceElement[]\",\r\n                \"references\": {\r\n                    \"HTMLAnimatePresenceElement\": {\r\n                        \"location\": \"global\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [{\r\n                        \"text\": undefined,\r\n                        \"name\": \"internal\"\r\n                    }],\r\n                \"text\": \"\"\r\n            },\r\n            \"defaultValue\": \"[]\"\r\n        },\r\n        \"observe\": {\r\n            \"type\": \"boolean\",\r\n            \"mutable\": true,\r\n            \"complexType\": {\r\n                \"original\": \"boolean\",\r\n                \"resolved\": \"boolean\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"If `true` (default), a MutationObserver will automatically be connected to enable animations when a child node enters/exits.\\n\\nIf you know the children are static (typical `animated-route-switch` use case), `false` may improve performance.\\n\\nNote: `<animate-presence>` elements which are children of a parent `<animate-presence>` element will inherit this value,\\n\\nwhich means MutationObservers can be disabled for the entire tree by setting `observe={false}` on the top-level element.\\n\\nHowever, directly set values always take precedence over inherited values.\"\r\n            },\r\n            \"attribute\": \"observe\",\r\n            \"reflect\": false\r\n        }\r\n    }; }\r\n    static get events() { return [{\r\n            \"method\": \"animatePresenceExitComplete\",\r\n            \"name\": \"animatePresenceExitComplete\",\r\n            \"bubbles\": true,\r\n            \"cancelable\": true,\r\n            \"composed\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"Fires when all exiting nodes have completed animating out.\\n\\nTo simplify listener behavior, this event bubbles, but never beyond the closest `<animate-presence>` parent.\"\r\n            },\r\n            \"complexType\": {\r\n                \"original\": \"void\",\r\n                \"resolved\": \"void\",\r\n                \"references\": {}\r\n            }\r\n        }, {\r\n            \"method\": \"animatePresenceEnter\",\r\n            \"name\": \"animatePresenceEnter\",\r\n            \"bubbles\": true,\r\n            \"cancelable\": true,\r\n            \"composed\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"Dispatched on a child when it enters. `event.target` is the entering child element.\\n\\nIt is recommended to use an animation handler created with `createPresenceHandler` for this event.\"\r\n            },\r\n            \"complexType\": {\r\n                \"original\": \"{ i: number }\",\r\n                \"resolved\": \"{ i: number; }\",\r\n                \"references\": {}\r\n            }\r\n        }, {\r\n            \"method\": \"animatePresenceExit\",\r\n            \"name\": \"animatePresenceExit\",\r\n            \"bubbles\": true,\r\n            \"cancelable\": true,\r\n            \"composed\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"Dispatched on a child when it exits. `event.target` is the exiting child element.\\n\\nIt is recommended to use an animation handler created with `createPresenceHandler` for this event.\"\r\n            },\r\n            \"complexType\": {\r\n                \"original\": \"{ i: number }\",\r\n                \"resolved\": \"{ i: number; }\",\r\n                \"references\": {}\r\n            }\r\n        }]; }\r\n    static get methods() { return {\r\n        \"registerChild\": {\r\n            \"complexType\": {\r\n                \"signature\": \"(el: HTMLAnimatePresenceElement) => Promise<void>\",\r\n                \"parameters\": [{\r\n                        \"tags\": [],\r\n                        \"text\": \"\"\r\n                    }],\r\n                \"references\": {\r\n                    \"Promise\": {\r\n                        \"location\": \"global\"\r\n                    },\r\n                    \"HTMLAnimatePresenceElement\": {\r\n                        \"location\": \"global\"\r\n                    }\r\n                },\r\n                \"return\": \"Promise<void>\"\r\n            },\r\n            \"docs\": {\r\n                \"text\": \"\",\r\n                \"tags\": [{\r\n                        \"name\": \"internal\",\r\n                        \"text\": \"Registers a child element across shadow boundaries\"\r\n                    }]\r\n            }\r\n        },\r\n        \"unregisterChild\": {\r\n            \"complexType\": {\r\n                \"signature\": \"(key: string) => Promise<void>\",\r\n                \"parameters\": [{\r\n                        \"tags\": [],\r\n                        \"text\": \"\"\r\n                    }],\r\n                \"references\": {\r\n                    \"Promise\": {\r\n                        \"location\": \"global\"\r\n                    }\r\n                },\r\n                \"return\": \"Promise<void>\"\r\n            },\r\n            \"docs\": {\r\n                \"text\": \"\",\r\n                \"tags\": [{\r\n                        \"name\": \"internal\",\r\n                        \"text\": undefined\r\n                    }]\r\n            }\r\n        },\r\n        \"exit\": {\r\n            \"complexType\": {\r\n                \"signature\": \"() => Promise<void>\",\r\n                \"parameters\": [],\r\n                \"references\": {\r\n                    \"Promise\": {\r\n                        \"location\": \"global\"\r\n                    },\r\n                    \"HTMLElement\": {\r\n                        \"location\": \"global\"\r\n                    }\r\n                },\r\n                \"return\": \"Promise<void>\"\r\n            },\r\n            \"docs\": {\r\n                \"text\": \"Programmatically triggers an exit.\\n\\nNested `<animate-presence>` children will be animated out from the bottom up, meaning that children elements trigger a parent's exit after their own exit finishes.\",\r\n                \"tags\": []\r\n            }\r\n        },\r\n        \"enter\": {\r\n            \"complexType\": {\r\n                \"signature\": \"() => Promise<void>\",\r\n                \"parameters\": [],\r\n                \"references\": {\r\n                    \"Promise\": {\r\n                        \"location\": \"global\"\r\n                    },\r\n                    \"HTMLElement\": {\r\n                        \"location\": \"global\"\r\n                    }\r\n                },\r\n                \"return\": \"Promise<void>\"\r\n            },\r\n            \"docs\": {\r\n                \"text\": \"Programmatically triggers an entrance.\\n\\nNested `<animate-presence>` children will be animated in from the top down, meaning that parent elements trigger a child's entrance after their own entrance finishes.\",\r\n                \"tags\": []\r\n            }\r\n        }\r\n    }; }\r\n    static get elementRef() { return \"element\"; }\r\n    static get watchers() { return [{\r\n            \"propName\": \"observe\",\r\n            \"methodName\": \"observeChanged\"\r\n        }]; }\r\n    static get listeners() { return [{\r\n            \"name\": \"animatePresenceExitComplete\",\r\n            \"method\": \"animatePresenceExitCompleteHandler\",\r\n            \"target\": undefined,\r\n            \"capture\": false,\r\n            \"passive\": false\r\n        }]; }\r\n}\r\nlet ids = 0;\r\n"]}