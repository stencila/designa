{"version":3,"sources":["node_modules/animate-presence/dist/collection/utils/path-to-regex.js","node_modules/animate-presence/dist/collection/utils/router.js","node_modules/animate-presence/dist/collection/components/animated-route-switch/animated-route-switch.js"],"names":["DEFAULT_DELIMITER","DEFAULT_DELIMITERS","PATH_REGEXP","RegExp","join","parse","str","options","tokens","key","index","path","defaultDelimiter","delimiter","delimiters","pathEscaped","res","exec","m","escaped","offset","slice","length","prev","next","name","capture","group","modifier","k","indexOf","push","partial","undefined","repeat","optional","pattern","prefix","escapeGroup","escapeString","substr","replace","flags","sensitive","regexpToRegexp","keys","groups","source","match","i","arrayToRegexp","parts","pathToRegexp","stringToRegexp","tokensToRegExp","strict","end","endsWith","concat","map","route","isEndDelimited","token","Array","isArray","cacheCount","patternCache","cacheLimit","compilePath","cacheKey","cache","cachePattern","JSON","stringify","re","compiledPattern","matchPath","pathname","exact","url","values","isExact","params","reduce","memo","getUniqueId","Math","random","toString","getMatch","isHTMLStencilRouteElement","elm","tagName","AnimatedRouteSwitch","[object Object]","hostRef","this","subscribers","location","regenerateSubscribers","console","warn","newLocation","log","newActiveIndex","prototype","call","el","children","filter","childElement","activeIndex","prevIndex","prevChild","exitChildren","activeChild","scrollTopOffset","componentUpdated","routeViewUpdatedOptions","queue","write","forEach","child","style","display","enterChildren","routeViewsUpdated","Object","assign","h"],"mappings":"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","sourcesContent":["/**\r\n * TS adaption of https://github.com/pillarjs/path-to-regexp/blob/master/index.js\r\n */\r\n/**\r\n * Default configs.\r\n */\r\nconst DEFAULT_DELIMITER = '/';\r\nconst DEFAULT_DELIMITERS = './';\r\n/**\r\n * The main path matching regexp utility.\r\n */\r\nconst PATH_REGEXP = new RegExp([\r\n    // Match escaped characters that would otherwise appear in future matches.\r\n    // This allows the user to escape special characters that won't transform.\r\n    '(\\\\\\\\.)',\r\n    // Match Express-style parameters and un-named parameters with a prefix\r\n    // and optional suffixes. Matches appear as:\r\n    //\r\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\r\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined]\r\n    '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?',\r\n].join('|'), 'g');\r\n/**\r\n * Parse a string for the raw tokens.\r\n */\r\nexport const parse = (str, options) => {\r\n    var tokens = [];\r\n    var key = 0;\r\n    var index = 0;\r\n    var path = '';\r\n    var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;\r\n    var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS;\r\n    var pathEscaped = false;\r\n    var res;\r\n    while ((res = PATH_REGEXP.exec(str)) !== null) {\r\n        var m = res[0];\r\n        var escaped = res[1];\r\n        var offset = res.index;\r\n        path += str.slice(index, offset);\r\n        index = offset + m.length;\r\n        // Ignore already escaped sequences.\r\n        if (escaped) {\r\n            path += escaped[1];\r\n            pathEscaped = true;\r\n            continue;\r\n        }\r\n        var prev = '';\r\n        var next = str[index];\r\n        var name = res[2];\r\n        var capture = res[3];\r\n        var group = res[4];\r\n        var modifier = res[5];\r\n        if (!pathEscaped && path.length) {\r\n            var k = path.length - 1;\r\n            if (delimiters.indexOf(path[k]) > -1) {\r\n                prev = path[k];\r\n                path = path.slice(0, k);\r\n            }\r\n        }\r\n        // Push the current path onto the tokens.\r\n        if (path) {\r\n            tokens.push(path);\r\n            path = '';\r\n            pathEscaped = false;\r\n        }\r\n        var partial = prev !== '' && next !== undefined && next !== prev;\r\n        var repeat = modifier === '+' || modifier === '*';\r\n        var optional = modifier === '?' || modifier === '*';\r\n        var delimiter = prev || defaultDelimiter;\r\n        var pattern = capture || group;\r\n        tokens.push({\r\n            name: name || key++,\r\n            prefix: prev,\r\n            delimiter: delimiter,\r\n            optional: optional,\r\n            repeat: repeat,\r\n            partial: partial,\r\n            pattern: pattern\r\n                ? escapeGroup(pattern)\r\n                : '[^' + escapeString(delimiter) + ']+?',\r\n        });\r\n    }\r\n    // Push any remaining characters.\r\n    if (path || index < str.length) {\r\n        tokens.push(path + str.substr(index));\r\n    }\r\n    return tokens;\r\n};\r\n/**\r\n * Compile a string to a template function for the path.\r\n */\r\nexport const compile = (str, options) => {\r\n    return tokensToFunction(parse(str, options));\r\n};\r\n/**\r\n * Expose a method for transforming tokens into the path function.\r\n */\r\nexport const tokensToFunction = (tokens) => {\r\n    // Compile all the tokens into regexps.\r\n    var matches = new Array(tokens.length);\r\n    // Compile all the patterns before compilation.\r\n    for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i];\r\n        if (typeof token === 'object') {\r\n            matches[i] = new RegExp('^(?:' + token.pattern + ')$');\r\n        }\r\n    }\r\n    return (data, options) => {\r\n        var path = '';\r\n        var encode = (options && options.encode) || encodeURIComponent;\r\n        for (var i = 0; i < tokens.length; i++) {\r\n            var token = tokens[i];\r\n            if (typeof token === 'string') {\r\n                path += token;\r\n                continue;\r\n            }\r\n            var value = data ? data[token.name] : undefined;\r\n            var segment;\r\n            if (Array.isArray(value)) {\r\n                if (!token.repeat) {\r\n                    throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array');\r\n                }\r\n                if (value.length === 0) {\r\n                    if (token.optional)\r\n                        continue;\r\n                    throw new TypeError('Expected \"' + token.name + '\" to not be empty');\r\n                }\r\n                for (var j = 0; j < value.length; j++) {\r\n                    segment = encode(value[j]);\r\n                    if (!matches[i].test(segment)) {\r\n                        throw new TypeError('Expected all \"' +\r\n                            token.name +\r\n                            '\" to match \"' +\r\n                            token.pattern +\r\n                            '\"');\r\n                    }\r\n                    path += (j === 0 ? token.prefix : token.delimiter) + segment;\r\n                }\r\n                continue;\r\n            }\r\n            if (typeof value === 'string' ||\r\n                typeof value === 'number' ||\r\n                typeof value === 'boolean') {\r\n                segment = encode(String(value));\r\n                if (!matches[i].test(segment)) {\r\n                    throw new TypeError('Expected \"' +\r\n                        token.name +\r\n                        '\" to match \"' +\r\n                        token.pattern +\r\n                        '\", but got \"' +\r\n                        segment +\r\n                        '\"');\r\n                }\r\n                path += token.prefix + segment;\r\n                continue;\r\n            }\r\n            if (token.optional) {\r\n                // Prepend partial segment prefixes.\r\n                if (token.partial)\r\n                    path += token.prefix;\r\n                continue;\r\n            }\r\n            throw new TypeError('Expected \"' +\r\n                token.name +\r\n                '\" to be ' +\r\n                (token.repeat ? 'an array' : 'a string'));\r\n        }\r\n        return path;\r\n    };\r\n};\r\n/**\r\n * Escape a regular expression string.\r\n */\r\nconst escapeString = (str) => {\r\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\r\n};\r\n/**\r\n * Escape the capturing group by escaping special characters and meaning.\r\n */\r\nconst escapeGroup = (group) => {\r\n    return group.replace(/([=!:$/()])/g, '\\\\$1');\r\n};\r\n/**\r\n * Get the flags for a regexp from the options.\r\n */\r\nconst flags = (options) => {\r\n    return options && options.sensitive ? '' : 'i';\r\n};\r\n/**\r\n * Pull out keys from a regexp.\r\n */\r\nconst regexpToRegexp = (path, keys) => {\r\n    if (!keys)\r\n        return path;\r\n    // Use a negative lookahead to match only capturing groups.\r\n    var groups = path.source.match(/\\((?!\\?)/g);\r\n    if (groups) {\r\n        for (var i = 0; i < groups.length; i++) {\r\n            keys.push({\r\n                name: i,\r\n                prefix: null,\r\n                delimiter: null,\r\n                optional: false,\r\n                repeat: false,\r\n                partial: false,\r\n                pattern: null,\r\n            });\r\n        }\r\n    }\r\n    return path;\r\n};\r\n/**\r\n * Transform an array into a regexp.\r\n */\r\nconst arrayToRegexp = (path, keys, options) => {\r\n    var parts = [];\r\n    for (var i = 0; i < path.length; i++) {\r\n        parts.push(pathToRegexp(path[i], keys, options).source);\r\n    }\r\n    return new RegExp('(?:' + parts.join('|') + ')', flags(options));\r\n};\r\n/**\r\n * Create a path regexp from string input.\r\n */\r\nconst stringToRegexp = (path, keys, options) => {\r\n    return tokensToRegExp(parse(path, options), keys, options);\r\n};\r\n/**\r\n * Expose a function for taking tokens and returning a RegExp.\r\n */\r\nexport const tokensToRegExp = (tokens, keys, options) => {\r\n    options = options || {};\r\n    var strict = options.strict;\r\n    var end = options.end !== false;\r\n    var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);\r\n    var delimiters = options.delimiters || DEFAULT_DELIMITERS;\r\n    var endsWith = []\r\n        .concat(options.endsWith || [])\r\n        .map(escapeString)\r\n        .concat('$')\r\n        .join('|');\r\n    var route = '';\r\n    var isEndDelimited = false;\r\n    // Iterate over the tokens and create our regexp string.\r\n    for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i];\r\n        if (typeof token === 'string') {\r\n            route += escapeString(token);\r\n            isEndDelimited =\r\n                i === tokens.length - 1 &&\r\n                    delimiters.indexOf(token[token.length - 1]) > -1;\r\n        }\r\n        else {\r\n            var prefix = escapeString(token.prefix || '');\r\n            var capture = token.repeat\r\n                ? '(?:' +\r\n                    token.pattern +\r\n                    ')(?:' +\r\n                    prefix +\r\n                    '(?:' +\r\n                    token.pattern +\r\n                    '))*'\r\n                : token.pattern;\r\n            if (keys)\r\n                keys.push(token);\r\n            if (token.optional) {\r\n                if (token.partial) {\r\n                    route += prefix + '(' + capture + ')?';\r\n                }\r\n                else {\r\n                    route += '(?:' + prefix + '(' + capture + '))?';\r\n                }\r\n            }\r\n            else {\r\n                route += prefix + '(' + capture + ')';\r\n            }\r\n        }\r\n    }\r\n    if (end) {\r\n        if (!strict)\r\n            route += '(?:' + delimiter + ')?';\r\n        route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';\r\n    }\r\n    else {\r\n        if (!strict)\r\n            route += '(?:' + delimiter + '(?=' + endsWith + '))?';\r\n        if (!isEndDelimited)\r\n            route += '(?=' + delimiter + '|' + endsWith + ')';\r\n    }\r\n    return new RegExp('^' + route, flags(options));\r\n};\r\n/**\r\n * Normalize the given path string, returning a regular expression.\r\n *\r\n * An empty array can be passed in for the keys, which will hold the\r\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\r\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\r\n */\r\nexport const pathToRegexp = (path, keys, options) => {\r\n    if (path instanceof RegExp) {\r\n        return regexpToRegexp(path, keys);\r\n    }\r\n    if (Array.isArray(path)) {\r\n        return arrayToRegexp(path, keys, options);\r\n    }\r\n    return stringToRegexp(path, keys, options);\r\n};\r\n","import { pathToRegexp } from './path-to-regex';\r\nlet cacheCount = 0;\r\nconst patternCache = {};\r\nconst cacheLimit = 10000;\r\n// Memoized function for creating the path match regex\r\nconst compilePath = (pattern, options) => {\r\n    const cacheKey = `${options.end}${options.strict}`;\r\n    const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\r\n    const cachePattern = JSON.stringify(pattern);\r\n    if (cache[cachePattern]) {\r\n        return cache[cachePattern];\r\n    }\r\n    const keys = [];\r\n    const re = pathToRegexp(pattern, keys, options);\r\n    const compiledPattern = { re, keys };\r\n    if (cacheCount < cacheLimit) {\r\n        cache[cachePattern] = compiledPattern;\r\n        cacheCount += 1;\r\n    }\r\n    return compiledPattern;\r\n};\r\n/**\r\n * Public API for matching a URL pathname to a path pattern.\r\n */\r\nexport const matchPath = (pathname, options = {}) => {\r\n    if (typeof options === 'string') {\r\n        options = { path: options };\r\n    }\r\n    const { path = '/', exact = false, strict = false } = options;\r\n    const { re, keys } = compilePath(path, { end: exact, strict });\r\n    const match = re.exec(pathname);\r\n    if (!match) {\r\n        return null;\r\n    }\r\n    const [url, ...values] = match;\r\n    const isExact = pathname === url;\r\n    if (exact && !isExact) {\r\n        return null;\r\n    }\r\n    return {\r\n        path,\r\n        url: path === '/' && url === '' ? '/' : url,\r\n        isExact,\r\n        params: keys.reduce((memo, key, index) => {\r\n            memo[key.name] = values[index];\r\n            return memo;\r\n        }, {}),\r\n    };\r\n};\r\n","import { h } from \"@stencil/core\";\r\nimport { matchPath } from '../../utils/router';\r\nimport { enterChildren, exitChildren } from '../../utils';\r\nconst getUniqueId = () => {\r\n    return ((Math.random() * 10e16).toString().match(/.{4}/g) || []).join('-');\r\n};\r\nconst getMatch = (pathname, url, exact) => {\r\n    return matchPath(pathname, {\r\n        path: url,\r\n        exact: exact,\r\n        strict: true,\r\n    });\r\n};\r\nconst isHTMLStencilRouteElement = (elm) => {\r\n    return elm.tagName === 'STENCIL-ROUTE';\r\n};\r\nexport class AnimatedRouteSwitch {\r\n    constructor() {\r\n        /** @internal */\r\n        this.group = getUniqueId();\r\n        this.subscribers = [];\r\n    }\r\n    componentWillLoad() {\r\n        if (this.location != null) {\r\n            this.regenerateSubscribers(this.location);\r\n        }\r\n        else {\r\n            console.warn(`<animated-route-switch> requires the \"location\" prop in order to be wired to Stencil Router.`);\r\n        }\r\n    }\r\n    async regenerateSubscribers(newLocation) {\r\n        console.log(newLocation);\r\n        if (newLocation == null) {\r\n            return;\r\n        }\r\n        let newActiveIndex = -1;\r\n        this.subscribers = Array.prototype.slice\r\n            .call(this.el.children)\r\n            .filter(isHTMLStencilRouteElement)\r\n            .map((childElement, index) => {\r\n            const match = getMatch(newLocation.pathname, childElement.url, childElement.exact);\r\n            if (match && newActiveIndex === -1) {\r\n                newActiveIndex = index;\r\n            }\r\n            return {\r\n                el: childElement,\r\n                match: match,\r\n            };\r\n        });\r\n        if (newActiveIndex === -1) {\r\n            return;\r\n        }\r\n        // Check if this actually changes which child is active\r\n        // then just pass the new match down if the active route isn't changing.\r\n        if (this.activeIndex === newActiveIndex) {\r\n            this.subscribers[newActiveIndex].el.match = this.subscribers[newActiveIndex].match;\r\n            return;\r\n        }\r\n        this.prevIndex = this.activeIndex;\r\n        this.activeIndex = newActiveIndex;\r\n        // Set all props on the new active route then wait until it says that it\r\n        // is completed\r\n        const prevChild = this.subscribers[this.prevIndex];\r\n        if (prevChild) {\r\n            await exitChildren(prevChild.el);\r\n        }\r\n        const activeChild = this.subscribers[this.activeIndex];\r\n        if (typeof this.scrollTopOffset === 'number') {\r\n            activeChild.el.scrollTopOffset = this.scrollTopOffset;\r\n        }\r\n        activeChild.el.group = this.group;\r\n        activeChild.el.match = activeChild.match;\r\n        activeChild.el.componentUpdated = (routeViewUpdatedOptions) => {\r\n            // After the new active route has completed then update visibility of routes\r\n            this.queue.write(() => {\r\n                this.subscribers.forEach((child, index) => {\r\n                    child.el.componentUpdated = undefined;\r\n                    if (index === this.activeIndex) {\r\n                        child.el.style.display = '';\r\n                        return enterChildren(child.el);\r\n                    }\r\n                    if (typeof this.scrollTopOffset === 'number') {\r\n                        child.el.scrollTopOffset = this.scrollTopOffset;\r\n                    }\r\n                    child.el.group = this.group;\r\n                    child.el.match = null;\r\n                    child.el.style.display = 'none';\r\n                });\r\n            });\r\n            if (this.routeViewsUpdated) {\r\n                this.routeViewsUpdated(Object.assign({ scrollTopOffset: this.scrollTopOffset }, routeViewUpdatedOptions));\r\n            }\r\n        };\r\n    }\r\n    render() {\r\n        return h(\"slot\", null);\r\n    }\r\n    static get is() { return \"animated-route-switch\"; }\r\n    static get properties() { return {\r\n        \"group\": {\r\n            \"type\": \"string\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"string\",\r\n                \"resolved\": \"string\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [{\r\n                        \"text\": undefined,\r\n                        \"name\": \"internal\"\r\n                    }],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"group\",\r\n            \"reflect\": true,\r\n            \"defaultValue\": \"getUniqueId()\"\r\n        },\r\n        \"routeViewsUpdated\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"(options: any) => void\",\r\n                \"resolved\": \"(options: any) => void\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [{\r\n                        \"text\": undefined,\r\n                        \"name\": \"internal\"\r\n                    }],\r\n                \"text\": \"\"\r\n            }\r\n        },\r\n        \"scrollTopOffset\": {\r\n            \"type\": \"number\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"number\",\r\n                \"resolved\": \"number\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"scroll-top-offset\",\r\n            \"reflect\": false\r\n        },\r\n        \"location\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"LocationSegments\",\r\n                \"resolved\": \"LocationSegments\",\r\n                \"references\": {\r\n                    \"LocationSegments\": {\r\n                        \"location\": \"import\",\r\n                        \"path\": \"../../utils/router\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            }\r\n        }\r\n    }; }\r\n    static get contextProps() { return [{\r\n            \"name\": \"queue\",\r\n            \"context\": \"queue\"\r\n        }]; }\r\n    static get elementRef() { return \"el\"; }\r\n    static get watchers() { return [{\r\n            \"propName\": \"location\",\r\n            \"methodName\": \"regenerateSubscribers\"\r\n        }]; }\r\n}\r\n"]}