{"version":3,"sources":["node_modules/@lezer/lr/dist/index.js"],"names":["Stack","p","stack","state","reducePos","pos","score","buffer","bufferBase","curContext","lookAhead","parent","this","prototype","toString","concat","filter","_","i","start","cx","parser","context","StackContext","Object","defineProperty","pushState","push","length","reduce","action","depth","type","dPrec","dynamicPrecedence","getGoto","minRepeatTerm","storeNode","reduceContext","base","count","stateFlag","baseStateID","pop","term","end","size","isReduce","cur","top","index","shift","next","nextEnd","nextState","maxNode","shiftContext","apply","useNode","value","reused","updateContext","tracker","reuse","stream","reset","split","off","slice","recoverByDelete","isNode","canShift","sim","SimulatedStack","stateSlot","hasAction","recoverByInsert","nextStates","best","s","some","v","result","forceReduce","validAction","target","forceAll","data","restart","sameState","other","dialectEnabled","dialectID","dialect","flags","emitContext","last","hash","emitLookAhead","newCx","setLookAhead","close","strict","Recover","goto","StackBufferCursor","maybeNext","create","fork","CachedToken","extended","mask","nullToken","InputStream","input","ranges","chunk","chunkOff","chunk2","chunk2Pos","token","rangeIndex","chunkPos","from","range","to","readNext","resolveOffset","offset","assoc","peek","idx","charCodeAt","resolved","acceptToken","endOffset","RangeError","getChunk","_a","nextChunk","advance","n","setDone","read","_i","r","Math","max","min","TokenGroup","id","readToken","contextual","fallback","extend","ExternalTokenizer","options","exports","group","groupMask","scan","accEnd","allows","overrides","low","high","mid","decodeArray","Type","Uint16Array","array","out","stop","digit","verbose","process","test","env","LOG","stackIDs","Safety","cutAt","tree","side","cursor","fullCursor","moveTo","childBefore","childAfter","isError","prevSibling","nextSibling","FragmentCursor","fragments","nodeSet","fragment","safeFrom","safeTo","trees","nextFragment","fr","openStart","openEnd","nextStart","nodeAt","children","positions","Tree","prop","NodeProp","TokenCache","tokens","mainToken","actions","tokenizers","map","getActions","actionIndex","main","tokenizer","updateCachedToken","startIndex","addActions","eofTerm","getMainToken","specialized","specializers","putAction","set","pair","Rec","Parse","recovering","nextStackID","minStackPos","stoppedAt","topTerm","stacks","bufferLength","newStacks","stopped","stoppedTokens","advanceStack","tok","finished","findFinished","stackToTree","console","log","getName","SyntaxError","runRecovery","maxRemaining","sort","a","b","outer","j","splice","stopAt","stackID","strictCx","cxHash","cached","match","types","contextHash","inner","defaultReduce","localStack","advanceFully","pushStackDedup","restarted","tokenEnd","deadEnd","done","force","forceBase","insert","build","topID","maxBufferLength","minRepeatType","WeakMap","get","String","fromCodePoint","Dialect","source","disabled","x","ContextTracker","spec","LRParser","_super","__extends","_this","call","wrappers","version","nodeNames","repeatNodeCount","topTerms","keys","topRules","nodeProps","setProp","nodeID","deserialize","propSpec","NodeSet","name","NodeType","define","undefined","props","indexOf","error","skipped","skippedNodes","DefaultBufferLength","tokenArray","tokenData","states","Uint32Array","stateData","maxTerm","dialects","dynamicPrecedences","tokenPrecTable","tokenPrec","termNames","parseDialect","createParse","parse","w","loose","table","groupTag","terminal","slot","flag","this_1","value_1","out_i_1","prev","iPrev","findOffset","configure","config","copy","assign","info","t","found","find","contextTracker","wrap","prec","values","part","id_1","id_2","Uint8Array","Parser","stacks_1"],"mappings":"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","sourcesContent":["import { Parser, NodeSet, NodeType, DefaultBufferLength, NodeProp, Tree } from '@lezer/common';\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nclass Stack {\n    /// @internal\n    constructor(\n    /// The parse that this stack is part of @internal\n    p, \n    /// Holds state, input pos, buffer index triplets for all but the\n    /// top state @internal\n    stack, \n    /// The current parse state @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    /// The input position up to which this stack has parsed.\n    pos, \n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    /// @internal\n    curContext, \n    /// @internal\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /// @internal\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /// @internal\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /// The stack's current [context](#lr.ContextTracker) value, if\n    /// any. Its type will depend on the context tracker's type\n    /// parameter, or it will be `null` if there is no context\n    /// tracker.\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /// @internal\n    reduce(action) {\n        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special case—they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        let start = this.stack[base - 2];\n        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /// @internal\n    storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /// @internal\n    shift(action, next, nextEnd) {\n        let start = this.pos;\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(action & 65535 /* ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(next, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = nextEnd;\n            this.shiftContext(next, start);\n            if (next <= this.p.parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n    }\n    // Apply an action\n    /// @internal\n    apply(action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /// @internal\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Delete */;\n    }\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /// @internal\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);\n            stack.pushState(s, this.pos);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.score -= 200 /* Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    forceReduce() {\n        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n        if ((reduce & 65536 /* ReduceFlag */) == 0)\n            return false;\n        let { parser } = this.p;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)\n                return false;\n            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);\n            this.score -= 100 /* Reduce */;\n        }\n        this.reduce(reduce);\n        return true;\n    }\n    /// @internal\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */)) {\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Err */, this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /// Check whether this state has no further actions (assumed to be a direct descendant of the\n    /// top state, since any other states must be able to continue\n    /// somehow). @internal\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&\n            !parser.stateSlot(this.state, 4 /* DefaultReduce */);\n    }\n    /// Restart the stack (put it back in its start state). Only safe\n    /// when this.stack.length == 3 (state is directly below the top\n    /// state). @internal\n    restart() {\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /// @internal\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /// Get the parser used by this stack.\n    get parser() { return this.p.parser; }\n    /// Test whether a given dialect (by numeric ID, as exported from\n    /// the terms file) is enabled.\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /// @internal\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);\n    }\n    /// @internal\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /// @internal\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /// @internal\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\nvar Recover;\n(function (Recover) {\n    Recover[Recover[\"Insert\"] = 200] = \"Insert\";\n    Recover[Recover[\"Delete\"] = 190] = \"Delete\";\n    Recover[Recover[\"Reduce\"] = 100] = \"Reduce\";\n    Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n    Recover[Recover[\"MaxInsertStackDepth\"] = 300] = \"MaxInsertStackDepth\";\n    Recover[Recover[\"DampenInsertStackDepth\"] = 120] = \"DampenInsertStackDepth\";\n})(Recover || (Recover = {}));\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/// [Tokenizers](#lr.ExternalTokenizer) interact with the input\n/// through this interface. It presents the input as a stream of\n/// characters, tracking lookahead and hiding the complexity of\n/// [ranges](#common.Parser.parse^ranges) from tokenizer code.\nclass InputStream {\n    /// @internal\n    constructor(\n    /// @internal\n    input, \n    /// @internal\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /// @internal\n        this.chunk = \"\";\n        /// @internal\n        this.chunkOff = 0;\n        /// Backup chunk\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /// The character code of the next code unit in the input, or -1\n        /// when the stream is at the end of the input.\n        this.next = -1;\n        /// @internal\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /// Look at a code unit near the stream position. `.peek(0)` equals\n    /// `.next`, `.peek(-1)` gives you the previous character, and so\n    /// on.\n    ///\n    /// Note that looking around during tokenizing creates dependencies\n    /// on potentially far-away content, which may reduce the\n    /// effectiveness incremental parsing—when looking forward—or even\n    /// cause invalid reparses when looking backward more than 25 code\n    /// units, since the library does not track lookbehind.\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead)\n            this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /// Accept a token. By default, the end of the token is set to the\n    /// current stream position, but you can pass an offset (relative to\n    /// the stream position) to change that.\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /// Move the stream forward N (defaults to 1) code units. Returns\n    /// the new value of [`next`](#lr.InputStream.next).\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead)\n            this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /// @internal\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /// @internal\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)\n            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/// @internal\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) { readToken(this.data, input, stack, this.id); }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/// `@external tokens` declarations in the grammar should resolve to\n/// an instance of this class.\nclass ExternalTokenizer {\n    /// Create a tokenizer. The first argument is the function that,\n    /// given an input stream, scans for the types of tokens it\n    /// recognizes at the stream's position, and calls\n    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    /// one.\n    constructor(\n    /// @internal\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `token` when it matches a token.\nfunction readToken(data, input, stack, group) {\n    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        // Do a binary search on the state's edges\n        for (let next = input.next, low = 0, high = data[state + 2]; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1];\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* BigValCode */) {\n                value = 65535 /* BigVal */;\n                break;\n            }\n            if (next >= 92 /* Gap2 */)\n                next--;\n            if (next >= 34 /* Gap1 */)\n                next--;\n            let digit = next - 32 /* Start */;\n            if (digit >= 46 /* Base */) {\n                digit -= 46 /* Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\n// FIXME find some way to reduce recovery work done when the input\n// doesn't match the grammar at all.\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nvar Safety;\n(function (Safety) {\n    Safety[Safety[\"Margin\"] = 25] = \"Margin\";\n})(Safety || (Safety = {}));\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.fullCursor();\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        tokenizer.token(this.stream.reset(stack.pos, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Err */;\n            token.end = Math.min(stack.p.stream.end, stack.pos + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {\n                if (data[i] == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Other */)\n                            index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nvar Rec;\n(function (Rec) {\n    Rec[Rec[\"Distance\"] = 5] = \"Distance\";\n    Rec[Rec[\"MaxRemainingPerStep\"] = 3] = \"MaxRemainingPerStep\";\n    // When two stacks have been running independently long enough to\n    // add this many elements to their buffers, prune one.\n    Rec[Rec[\"MinBufferLengthPrune\"] = 500] = \"MinBufferLengthPrune\";\n    Rec[Rec[\"ForceReduceLimit\"] = 10] = \"ForceReduceLimit\";\n    // Once a stack reaches this depth (in .stack.length) force-reduce\n    // it back to CutTo to avoid creating trees that overflow the stack\n    // on recursive traversal.\n    Rec[Rec[\"CutDepth\"] = 15000] = \"CutDepth\";\n    Rec[Rec[\"CutTo\"] = 9000] = \"CutTo\";\n})(Rec || (Rec = {}));\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished)\n                return this.stackToTree(finished);\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]\n                : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished)\n                return this.stackToTree(finished.forceAll());\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 500 /* MinBufferLengthPrune */ && other.buffer.length > 500 /* MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);\n            return true;\n        }\n        if (stack.stack.length >= 15000 /* CutDepth */) {\n            while (stack.stack.length > 9000 /* CutTo */ && stack.forceReduce()) { }\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/// Context trackers are used to track stateful context (such as\n/// indentation in the Python grammar, or parent elements in the XML\n/// grammar) needed by external tokenizers. You declare them in a\n/// grammar file as `@context exportName from \"module\"`.\n///\n/// Context values should be immutable, and can be updated (replaced)\n/// on shift or reduce actions.\n///\n/// The export used in a `@context` declaration should be of this\n/// type.\nclass ContextTracker {\n    /// Define a context tracker.\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nclass LRParser extends Parser {\n    /// @internal\n    constructor(spec) {\n        super();\n        /// @internal\n        this.wrappers = [];\n        if (spec.version != 13 /* Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        this.strict = false;\n        this.bufferLength = DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);\n        this.specializers = [];\n        if (spec.specialized)\n            for (let i = 0; i < spec.specialized.length; i++) {\n                this.specialized[i] = spec.specialized[i].term;\n                this.specializers[i] = spec.specialized[i].get;\n            }\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Get a goto table entry @internal\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /// Check if this state has an action for a given terminal @internal\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /// @internal\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* Size */) + slot];\n    }\n    /// @internal\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;\n    }\n    /// @internal\n    validAction(state, action) {\n        if (action == this.stateSlot(state, 4 /* DefaultReduce */))\n            return true;\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    return false;\n            }\n            if (action == pair(this.data, i + 1))\n                return true;\n        }\n    }\n    /// Get the states that can follow this one through shift actions or\n    /// goto jumps. @internal\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /// @internal\n    overrides(token, prev) {\n        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    }\n    /// Configure the parser. Returns a new parser instance that has the\n    /// given settings modified. Settings not provided in `config` are\n    /// kept from the original parser.\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /// The eof term id is always allocated directly after the node\n    /// types. @internal\n    get eofTerm() { return this.maxNode + 1; }\n    /// The type of top node produced by the parser.\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /// @internal\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /// @internal\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /// (used by the output of the parser generator) @internal\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\n\nexport { ContextTracker, ExternalTokenizer, InputStream, LRParser, Stack };\n"]}