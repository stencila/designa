{"version":3,"sources":["node_modules/mimic-fn/index.js","node_modules/p-defer/index.js","node_modules/map-age-cleaner/dist/index.js","node_modules/mem/dist/index.js","src/components/toast/toastController.ts"],"names":["copyProperty","to","from","property","ignoreNonConfigurable","toDescriptor","Object","getOwnPropertyDescriptor","fromDescriptor","canCopyProperty","defineProperty","undefined","configurable","writable","enumerable","value","changePrototype","fromPrototype","getPrototypeOf","setPrototypeOf","wrappedToString","withName","fromBody","toStringDescriptor","Function","prototype","toStringName","toString","changeToString","name","trim","newToString","bind","mimicFn","Reflect","ownKeys","mimicFn_1","pDefer","ret","promise","Promise","resolve","reject","__awaiter","this","thisArg","_arguments","P","generator","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","default","exports","p_defer_1","require$$0","mapAgeCleaner","map","processingKey","processingTimer","processingDeferred","cleanup","setupTimer","item","delay","Date","now","delete","setTimeout","unref","entry","_a","reset","clearTimeout","originalSet","set","key","has","module","decoratorInstanceMap","WeakMap","cacheStore","mem","fn","cacheKey","cache","Map","maxAge","memoized","arguments_","cacheItem","get","data","Number","POSITIVE_INFINITY","decorator","options","target","propertyKey","descriptor","input","TypeError","clear","dist","ToastTypes","ToastPositions","init","toastContainer","document","querySelector","container","createElement","position","body","append","toastController","baseOptions","present","message","toastEl","type","_b","neutral","_d","_c","topCenter","dismissable","_e","duration","_f","innerText","memoizedPresent","JSON","stringify"],"mappings":"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","sourcesContent":["'use strict';\n\nconst copyProperty = (to, from, property, ignoreNonConfigurable) => {\n\t// `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n\t// `Function#prototype` is non-writable and non-configurable so can never be modified.\n\tif (property === 'length' || property === 'prototype') {\n\t\treturn;\n\t}\n\n\t// `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\tif (property === 'arguments' || property === 'caller') {\n\t\treturn;\n\t}\n\n\tconst toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n\tconst fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n\tif (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n\t\treturn;\n\t}\n\n\tObject.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n//  - one its descriptors is changed\n//  - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n\treturn toDescriptor === undefined || toDescriptor.configurable || (\n\t\ttoDescriptor.writable === fromDescriptor.writable &&\n\t\ttoDescriptor.enumerable === fromDescriptor.enumerable &&\n\t\ttoDescriptor.configurable === fromDescriptor.configurable &&\n\t\t(toDescriptor.writable || toDescriptor.value === fromDescriptor.value)\n\t);\n};\n\nconst changePrototype = (to, from) => {\n\tconst fromPrototype = Object.getPrototypeOf(from);\n\tif (fromPrototype === Object.getPrototypeOf(to)) {\n\t\treturn;\n\t}\n\n\tObject.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n\tconst withName = name === '' ? '' : `with ${name.trim()}() `;\n\tconst newToString = wrappedToString.bind(null, withName, from.toString());\n\t// Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\tObject.defineProperty(newToString, 'name', toStringName);\n\tObject.defineProperty(to, 'toString', {...toStringDescriptor, value: newToString});\n};\n\nconst mimicFn = (to, from, {ignoreNonConfigurable = false} = {}) => {\n\tconst {name} = to;\n\n\tfor (const property of Reflect.ownKeys(from)) {\n\t\tcopyProperty(to, from, property, ignoreNonConfigurable);\n\t}\n\n\tchangePrototype(to, from);\n\tchangeToString(to, from, name);\n\n\treturn to;\n};\n\nmodule.exports = mimicFn;\n","'use strict';\nmodule.exports = () => {\n\tconst ret = {};\n\n\tret.promise = new Promise((resolve, reject) => {\n\t\tret.resolve = resolve;\n\t\tret.reject = reject;\n\t});\n\n\treturn ret;\n};\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst p_defer_1 = __importDefault(require(\"p-defer\"));\nfunction mapAgeCleaner(map, property = 'maxAge') {\n    let processingKey;\n    let processingTimer;\n    let processingDeferred;\n    const cleanup = () => __awaiter(this, void 0, void 0, function* () {\n        if (processingKey !== undefined) {\n            // If we are already processing an item, we can safely exit\n            return;\n        }\n        const setupTimer = (item) => __awaiter(this, void 0, void 0, function* () {\n            processingDeferred = p_defer_1.default();\n            const delay = item[1][property] - Date.now();\n            if (delay <= 0) {\n                // Remove the item immediately if the delay is equal to or below 0\n                map.delete(item[0]);\n                processingDeferred.resolve();\n                return;\n            }\n            // Keep track of the current processed key\n            processingKey = item[0];\n            processingTimer = setTimeout(() => {\n                // Remove the item when the timeout fires\n                map.delete(item[0]);\n                if (processingDeferred) {\n                    processingDeferred.resolve();\n                }\n            }, delay);\n            // tslint:disable-next-line:strict-type-predicates\n            if (typeof processingTimer.unref === 'function') {\n                // Don't hold up the process from exiting\n                processingTimer.unref();\n            }\n            return processingDeferred.promise;\n        });\n        try {\n            for (const entry of map) {\n                yield setupTimer(entry);\n            }\n        }\n        catch (_a) {\n            // Do nothing if an error occurs, this means the timer was cleaned up and we should stop processing\n        }\n        processingKey = undefined;\n    });\n    const reset = () => {\n        processingKey = undefined;\n        if (processingTimer !== undefined) {\n            clearTimeout(processingTimer);\n            processingTimer = undefined;\n        }\n        if (processingDeferred !== undefined) { // tslint:disable-line:early-exit\n            processingDeferred.reject(undefined);\n            processingDeferred = undefined;\n        }\n    };\n    const originalSet = map.set.bind(map);\n    map.set = (key, value) => {\n        if (map.has(key)) {\n            // If the key already exist, remove it so we can add it back at the end of the map.\n            map.delete(key);\n        }\n        // Call the original `map.set`\n        const result = originalSet(key, value);\n        // If we are already processing a key and the key added is the current processed key, stop processing it\n        if (processingKey && processingKey === key) {\n            reset();\n        }\n        // Always run the cleanup method in case it wasn't started yet\n        cleanup(); // tslint:disable-line:no-floating-promises\n        return result;\n    };\n    cleanup(); // tslint:disable-line:no-floating-promises\n    return map;\n}\nexports.default = mapAgeCleaner;\n// Add support for CJS\nmodule.exports = mapAgeCleaner;\nmodule.exports.default = mapAgeCleaner;\n","'use strict';\nconst mimicFn = require(\"mimic-fn\");\nconst mapAgeCleaner = require(\"map-age-cleaner\");\nconst decoratorInstanceMap = new WeakMap();\nconst cacheStore = new WeakMap();\n/**\n[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.\n\n@param fn - Function to be memoized.\n\n@example\n```\nimport mem = require('mem');\n\nlet i = 0;\nconst counter = () => ++i;\nconst memoized = mem(counter);\n\nmemoized('foo');\n//=> 1\n\n// Cached as it's the same arguments\nmemoized('foo');\n//=> 1\n\n// Not cached anymore as the arguments changed\nmemoized('bar');\n//=> 2\n\nmemoized('bar');\n//=> 2\n```\n*/\nconst mem = (fn, { cacheKey, cache = new Map(), maxAge } = {}) => {\n    if (typeof maxAge === 'number') {\n        // TODO: Drop after https://github.com/SamVerschueren/map-age-cleaner/issues/5\n        // @ts-expect-error\n        mapAgeCleaner(cache);\n    }\n    const memoized = function (...arguments_) {\n        const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\n        const cacheItem = cache.get(key);\n        if (cacheItem) {\n            return cacheItem.data;\n        }\n        const result = fn.apply(this, arguments_);\n        cache.set(key, {\n            data: result,\n            maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY\n        });\n        return result;\n    };\n    mimicFn(memoized, fn, {\n        ignoreNonConfigurable: true\n    });\n    cacheStore.set(memoized, cache);\n    return memoized;\n};\n/**\n@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.\n\n@example\n```\nimport mem = require('mem');\n\nclass Example {\n    index = 0\n\n    @mem.decorator()\n    counter() {\n        return ++this.index;\n    }\n}\n\nclass ExampleWithOptions {\n    index = 0\n\n    @mem.decorator({maxAge: 1000})\n    counter() {\n        return ++this.index;\n    }\n}\n```\n*/\nmem.decorator = (options = {}) => (target, propertyKey, descriptor) => {\n    const input = target[propertyKey];\n    if (typeof input !== 'function') {\n        throw new TypeError('The decorated value must be a function');\n    }\n    delete descriptor.value;\n    delete descriptor.writable;\n    descriptor.get = function () {\n        if (!decoratorInstanceMap.has(this)) {\n            const value = mem(input, options);\n            decoratorInstanceMap.set(this, value);\n            return value;\n        }\n        return decoratorInstanceMap.get(this);\n    };\n};\n/**\nClear all cached data of a memoized function.\n\n@param fn - Memoized function.\n*/\nmem.clear = (fn) => {\n    const cache = cacheStore.get(fn);\n    if (!cache) {\n        throw new TypeError('Can\\'t clear a function that was not memoized!');\n    }\n    if (typeof cache.clear !== 'function') {\n        throw new TypeError('The cache Map can\\'t be cleared!');\n    }\n    cache.clear();\n};\nmodule.exports = mem;\n","import mem from 'mem'\nimport { Components } from '../../components'\n\nexport enum ToastTypes {\n  neutral = 'neutral',\n  success = 'success',\n  warn = 'warn',\n  danger = 'danger',\n}\n\nexport type ToastType = keyof typeof ToastTypes\n\nexport enum ToastPositions {\n  topStart = 'topStart',\n  topCenter = 'topCenter',\n  topEnd = 'topEnd',\n  bottomStart = 'bottomStart',\n  bottomCenter = 'bottomCenter',\n  bottomEnd = 'bottomEnd',\n}\n\nexport type ToastPosition = keyof typeof ToastPositions\n\ntype ToastOptions = Partial<Components.StencilaToast>\n\nconst init = (options: ToastOptions): Element | HTMLElement => {\n  const toastContainer = document.querySelector('stencila-toast-container')\n\n  if (toastContainer) {\n    return toastContainer\n  }\n\n  const container = document.createElement('stencila-toast-container')\n\n  if (options.position !== undefined) {\n    container.position = options.position\n  }\n\n  document.body.append(container)\n  return container\n}\n\n// ==============================================================================\n\ninterface ToastController {\n  present: (message: string, options?: ToastOptions) => HTMLStencilaToastElement\n}\n\n// Base Toast controller function for managing the presentation of `stencila-toast` components\nexport const toastController = (\n  baseOptions: ToastOptions = {}\n): ToastController => {\n  const present = (\n    message: string,\n    options: ToastOptions | undefined = {}\n  ): HTMLStencilaToastElement => {\n    const toastEl = document.createElement('stencila-toast')\n\n    toastEl.type = options.type ?? baseOptions.type ?? ToastTypes.neutral\n    toastEl.position =\n      options.position ?? baseOptions.position ?? ToastPositions.topCenter\n    toastEl.dismissable = options.dismissable ?? baseOptions.dismissable\n    toastEl.duration = options.duration ?? baseOptions.duration\n\n    toastEl.innerText = message\n    init(baseOptions).append(toastEl)\n    return toastEl\n  }\n\n  /** Memoize the notification function based on the message string and options to avoid showing\n   * duplicate notifications in quick succession.\n   */\n  const memoizedPresent = mem(present, {\n    cacheKey: JSON.stringify,\n    maxAge: 150,\n  })\n\n  return {\n    present: memoizedPresent,\n  }\n}\n"]}