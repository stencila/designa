{"version":3,"sources":["node_modules/animate-presence/dist/collection/components/animate-presence/animate-presence.js"],"names":["hold","el","async","cb","dataset","then","r","finished","AnimatePresence","[object Object]","hostRef","this","__presenceKey","ids","descendants","getClosestParent","_a","base","element","parentElement","getRootNode","host","closest","tagName","willExit","didExit","willEnter","didEnter","handleMutation","bind","observe","addMO","mo","childList","attributes","attributeFilter","removeMO","_b","injectGlobalStyle","ancestor","Array","from","children","map","i","setCustomProperties","style","setProperty","enter","observeChanged","registerChild","unregisterChild","exit","event","CustomEvent","bubbles","detail","dispatchEvent","removeProperty","presence","afterSelf","initial","enterChildren","method","exitChildren","remove","Promise","resolve","node","_record","isHTMLElement","hasData","exitNode","enterNode","record","previousSibling","insertAdjacentElement","target","prepend","records","reverse","addedNodes","length","handleEnter","removedNodes","handleExit","window","MutationObserver","disconnect","undefined","key","filter","stopPropagation","all","animatePresenceExitComplete","emit","h","Host","display"],"mappings":"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","sourcesContent":["import { h, Host } from \"@stencil/core\";\r\nimport { setCustomProperties, isHTMLElement, hasData, presence, closest, enterChildren, exitChildren, injectGlobalStyle, } from '../../utils';\r\nconst hold = (el) => async (cb) => {\r\n    el.dataset.hold = '';\r\n    await cb(el).then((r) => {\r\n        if (r && 'finished' in r) {\r\n            return r.finished;\r\n        }\r\n        return;\r\n    });\r\n    delete el.dataset.hold;\r\n};\r\nexport class AnimatePresence {\r\n    constructor() {\r\n        /** @internal */\r\n        this.__presenceKey = `animate-presence-${ids++}`;\r\n        /** @internal */\r\n        this.descendants = [];\r\n        this.getClosestParent = () => {\r\n            var _a;\r\n            const base = (_a = this.element.parentElement, (_a !== null && _a !== void 0 ? _a : this.element.getRootNode().host));\r\n            return closest(this.element.tagName, base);\r\n        };\r\n        this.willExit = false;\r\n        this.didExit = false;\r\n        this.willEnter = false;\r\n        this.didEnter = false;\r\n        this.handleMutation = this.handleMutation.bind(this);\r\n    }\r\n    observeChanged() {\r\n        if (this.observe) {\r\n            this.addMO();\r\n            this.mo.observe(this.element, {\r\n                childList: true,\r\n                attributes: true,\r\n                attributeFilter: ['data-key'],\r\n            });\r\n        }\r\n        else {\r\n            this.removeMO();\r\n        }\r\n    }\r\n    async componentWillLoad() {\r\n        var _a, _b;\r\n        injectGlobalStyle();\r\n        this.ancestor = this.getClosestParent();\r\n        if (typeof this.observe === 'undefined') {\r\n            this.observe = (_b = (_a = this.ancestor) === null || _a === void 0 ? void 0 : _a.observe, (_b !== null && _b !== void 0 ? _b : true));\r\n        }\r\n        Array.from(this.element.children).map((el, i) => {\r\n            setCustomProperties(el, { i });\r\n            el.style.setProperty('animation-play-state', 'paused');\r\n            el.dataset.enter = '';\r\n        });\r\n    }\r\n    async componentDidLoad() {\r\n        var _a;\r\n        this.observeChanged();\r\n        (_a = this.ancestor) === null || _a === void 0 ? void 0 : _a.registerChild(this.element);\r\n        if (!this.ancestor) {\r\n            this.enter();\r\n        }\r\n    }\r\n    async componentDidUnload() {\r\n        var _a;\r\n        this.removeMO();\r\n        (_a = this.ancestor) === null || _a === void 0 ? void 0 : _a.unregisterChild(this.__presenceKey);\r\n        this.descendants = [];\r\n    }\r\n    async enterNode(el, i = 0) {\r\n        delete el.dataset.exit;\r\n        const event = new CustomEvent('animatePresenceEnter', {\r\n            bubbles: true,\r\n            detail: {\r\n                i,\r\n                hold: hold(el),\r\n            },\r\n        });\r\n        el.dispatchEvent(event);\r\n        el.style.removeProperty('animation-play-state');\r\n        el.dataset.enter = '';\r\n        setCustomProperties(el, { i });\r\n        await presence(el, {\r\n            afterSelf: async () => {\r\n                delete el.dataset.initial;\r\n                delete el.dataset.enter;\r\n                el.style.removeProperty('--i');\r\n            },\r\n        });\r\n        return enterChildren(el);\r\n    }\r\n    async exitNode(el, method = 'remove', i = 0) {\r\n        await exitChildren(el);\r\n        delete el.dataset.willExit;\r\n        setCustomProperties(el, { i });\r\n        const event = new CustomEvent('animatePresenceExit', {\r\n            bubbles: true,\r\n            detail: {\r\n                i,\r\n                hold: hold(el),\r\n            },\r\n        });\r\n        el.dispatchEvent(event);\r\n        el.dataset.exit = '';\r\n        await presence(el, {\r\n            afterSelf: () => {\r\n                if (method === 'remove') {\r\n                    el.remove();\r\n                }\r\n                else if (method === 'hide') {\r\n                    el.style.setProperty('visibility', 'hidden');\r\n                }\r\n            },\r\n        });\r\n        return Promise.resolve();\r\n    }\r\n    async handleEnter(node, _record, i) {\r\n        if (!isHTMLElement(node))\r\n            return;\r\n        if (hasData(node, 'exit'))\r\n            return;\r\n        if (hasData(node, 'willExit')) {\r\n            return this.exitNode(node, 'remove', i);\r\n        }\r\n        else {\r\n            return this.enterNode(node, i);\r\n        }\r\n    }\r\n    async handleExit(node, record, i) {\r\n        if (!isHTMLElement(node))\r\n            return;\r\n        if (hasData(node, 'exit') || hasData(node, 'willExit')) {\r\n            return;\r\n        }\r\n        node.dataset.willExit = '';\r\n        setCustomProperties(node, { i });\r\n        if (isHTMLElement(record.previousSibling)) {\r\n            record.previousSibling.insertAdjacentElement('afterend', node);\r\n        }\r\n        else if (isHTMLElement(record.target)) {\r\n            record.target.prepend(node);\r\n        }\r\n    }\r\n    handleMutation(records) {\r\n        let i = 0;\r\n        for (const record of records.reverse()) {\r\n            if (record.addedNodes.length === 1) {\r\n                this.handleEnter(record.addedNodes[0], record, records.length - 1 - i);\r\n            }\r\n            if (record.removedNodes.length === 1) {\r\n                this.handleExit(record.removedNodes[0], record, i);\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    addMO() {\r\n        if (!this.mo) {\r\n            if ('MutationObserver' in window) {\r\n                this.mo = new MutationObserver(this.handleMutation);\r\n                this.observeChanged();\r\n            }\r\n        }\r\n    }\r\n    removeMO() {\r\n        if (this.mo) {\r\n            this.mo.disconnect();\r\n            this.mo = undefined;\r\n        }\r\n    }\r\n    /** @internal Registers a child element across shadow boundaries */\r\n    async registerChild(el) {\r\n        const key = el.__presenceKey;\r\n        // Remove existing elements with same key to handle HMR\r\n        this.descendants = [\r\n            ...this.descendants.filter(element => element.__presenceKey !== key),\r\n            el,\r\n        ];\r\n        return;\r\n    }\r\n    /** @internal */\r\n    async unregisterChild(key) {\r\n        this.descendants = this.descendants.filter(el => el.__presenceKey !== key);\r\n        return;\r\n    }\r\n    animatePresenceExitCompleteHandler(event) {\r\n        event.stopPropagation();\r\n    }\r\n    /**\r\n     * Programmatically triggers an exit.\r\n     *\r\n     * Nested `<animate-presence>` children will be animated out from the bottom up, meaning that children elements trigger a parent's exit after their own exit finishes.\r\n     */\r\n    async exit() {\r\n        if (this.didExit || this.willExit)\r\n            return;\r\n        this.willExit = true;\r\n        await Promise.all(Array.from(this.element.children)\r\n            .reverse()\r\n            .map((el, i) => this.exitNode(el, 'hide', i)));\r\n        this.didExit = true;\r\n        this.willExit = false;\r\n        this.animatePresenceExitComplete.emit();\r\n        return Promise.resolve();\r\n    }\r\n    /**\r\n     * Programmatically triggers an entrance.\r\n     *\r\n     * Nested `<animate-presence>` children will be animated in from the top down, meaning that parent elements trigger a child's entrance after their own entrance finishes.\r\n     */\r\n    async enter() {\r\n        this.didExit = false;\r\n        this.willExit = false;\r\n        if (this.didEnter || this.willEnter)\r\n            return;\r\n        this.willEnter = true;\r\n        await Promise.all(Array.from(this.element.children).map((el, i) => this.enterNode(el, i)));\r\n        await enterChildren(this.element);\r\n        this.didEnter = true;\r\n        this.willEnter = false;\r\n        return Promise.resolve();\r\n    }\r\n    render() {\r\n        return (h(Host, { style: { display: 'contents' } },\r\n            h(\"slot\", null)));\r\n    }\r\n    static get is() { return \"animate-presence\"; }\r\n    static get encapsulation() { return \"shadow\"; }\r\n    static get properties() { return {\r\n        \"__presenceKey\": {\r\n            \"type\": \"string\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"string\",\r\n                \"resolved\": \"string\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [{\r\n                        \"text\": undefined,\r\n                        \"name\": \"internal\"\r\n                    }],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"__presence-key\",\r\n            \"reflect\": false,\r\n            \"defaultValue\": \"`animate-presence-${ids++}`\"\r\n        },\r\n        \"descendants\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"HTMLAnimatePresenceElement[]\",\r\n                \"resolved\": \"HTMLAnimatePresenceElement[]\",\r\n                \"references\": {\r\n                    \"HTMLAnimatePresenceElement\": {\r\n                        \"location\": \"global\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [{\r\n                        \"text\": undefined,\r\n                        \"name\": \"internal\"\r\n                    }],\r\n                \"text\": \"\"\r\n            },\r\n            \"defaultValue\": \"[]\"\r\n        },\r\n        \"observe\": {\r\n            \"type\": \"boolean\",\r\n            \"mutable\": true,\r\n            \"complexType\": {\r\n                \"original\": \"boolean\",\r\n                \"resolved\": \"boolean\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"If `true` (default), a MutationObserver will automatically be connected to enable animations when a child node enters/exits.\\n\\nIf you know the children are static (typical `animated-route-switch` use case), `false` may improve performance.\\n\\nNote: `<animate-presence>` elements which are children of a parent `<animate-presence>` element will inherit this value,\\n\\nwhich means MutationObservers can be disabled for the entire tree by setting `observe={false}` on the top-level element.\\n\\nHowever, directly set values always take precedence over inherited values.\"\r\n            },\r\n            \"attribute\": \"observe\",\r\n            \"reflect\": false\r\n        }\r\n    }; }\r\n    static get events() { return [{\r\n            \"method\": \"animatePresenceExitComplete\",\r\n            \"name\": \"animatePresenceExitComplete\",\r\n            \"bubbles\": true,\r\n            \"cancelable\": true,\r\n            \"composed\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"Fires when all exiting nodes have completed animating out.\\n\\nTo simplify listener behavior, this event bubbles, but never beyond the closest `<animate-presence>` parent.\"\r\n            },\r\n            \"complexType\": {\r\n                \"original\": \"void\",\r\n                \"resolved\": \"void\",\r\n                \"references\": {}\r\n            }\r\n        }, {\r\n            \"method\": \"animatePresenceEnter\",\r\n            \"name\": \"animatePresenceEnter\",\r\n            \"bubbles\": true,\r\n            \"cancelable\": true,\r\n            \"composed\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"Dispatched on a child when it enters. `event.target` is the entering child element.\\n\\nIt is recommended to use an animation handler created with `createPresenceHandler` for this event.\"\r\n            },\r\n            \"complexType\": {\r\n                \"original\": \"{ i: number }\",\r\n                \"resolved\": \"{ i: number; }\",\r\n                \"references\": {}\r\n            }\r\n        }, {\r\n            \"method\": \"animatePresenceExit\",\r\n            \"name\": \"animatePresenceExit\",\r\n            \"bubbles\": true,\r\n            \"cancelable\": true,\r\n            \"composed\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"Dispatched on a child when it exits. `event.target` is the exiting child element.\\n\\nIt is recommended to use an animation handler created with `createPresenceHandler` for this event.\"\r\n            },\r\n            \"complexType\": {\r\n                \"original\": \"{ i: number }\",\r\n                \"resolved\": \"{ i: number; }\",\r\n                \"references\": {}\r\n            }\r\n        }]; }\r\n    static get methods() { return {\r\n        \"registerChild\": {\r\n            \"complexType\": {\r\n                \"signature\": \"(el: HTMLAnimatePresenceElement) => Promise<void>\",\r\n                \"parameters\": [{\r\n                        \"tags\": [],\r\n                        \"text\": \"\"\r\n                    }],\r\n                \"references\": {\r\n                    \"Promise\": {\r\n                        \"location\": \"global\"\r\n                    },\r\n                    \"HTMLAnimatePresenceElement\": {\r\n                        \"location\": \"global\"\r\n                    }\r\n                },\r\n                \"return\": \"Promise<void>\"\r\n            },\r\n            \"docs\": {\r\n                \"text\": \"\",\r\n                \"tags\": [{\r\n                        \"name\": \"internal\",\r\n                        \"text\": \"Registers a child element across shadow boundaries\"\r\n                    }]\r\n            }\r\n        },\r\n        \"unregisterChild\": {\r\n            \"complexType\": {\r\n                \"signature\": \"(key: string) => Promise<void>\",\r\n                \"parameters\": [{\r\n                        \"tags\": [],\r\n                        \"text\": \"\"\r\n                    }],\r\n                \"references\": {\r\n                    \"Promise\": {\r\n                        \"location\": \"global\"\r\n                    }\r\n                },\r\n                \"return\": \"Promise<void>\"\r\n            },\r\n            \"docs\": {\r\n                \"text\": \"\",\r\n                \"tags\": [{\r\n                        \"name\": \"internal\",\r\n                        \"text\": undefined\r\n                    }]\r\n            }\r\n        },\r\n        \"exit\": {\r\n            \"complexType\": {\r\n                \"signature\": \"() => Promise<void>\",\r\n                \"parameters\": [],\r\n                \"references\": {\r\n                    \"Promise\": {\r\n                        \"location\": \"global\"\r\n                    },\r\n                    \"HTMLElement\": {\r\n                        \"location\": \"global\"\r\n                    }\r\n                },\r\n                \"return\": \"Promise<void>\"\r\n            },\r\n            \"docs\": {\r\n                \"text\": \"Programmatically triggers an exit.\\n\\nNested `<animate-presence>` children will be animated out from the bottom up, meaning that children elements trigger a parent's exit after their own exit finishes.\",\r\n                \"tags\": []\r\n            }\r\n        },\r\n        \"enter\": {\r\n            \"complexType\": {\r\n                \"signature\": \"() => Promise<void>\",\r\n                \"parameters\": [],\r\n                \"references\": {\r\n                    \"Promise\": {\r\n                        \"location\": \"global\"\r\n                    },\r\n                    \"HTMLElement\": {\r\n                        \"location\": \"global\"\r\n                    }\r\n                },\r\n                \"return\": \"Promise<void>\"\r\n            },\r\n            \"docs\": {\r\n                \"text\": \"Programmatically triggers an entrance.\\n\\nNested `<animate-presence>` children will be animated in from the top down, meaning that parent elements trigger a child's entrance after their own entrance finishes.\",\r\n                \"tags\": []\r\n            }\r\n        }\r\n    }; }\r\n    static get elementRef() { return \"element\"; }\r\n    static get watchers() { return [{\r\n            \"propName\": \"observe\",\r\n            \"methodName\": \"observeChanged\"\r\n        }]; }\r\n    static get listeners() { return [{\r\n            \"name\": \"animatePresenceExitComplete\",\r\n            \"method\": \"animatePresenceExitCompleteHandler\",\r\n            \"target\": undefined,\r\n            \"capture\": false,\r\n            \"passive\": false\r\n        }]; }\r\n}\r\nlet ids = 0;\r\n"]}